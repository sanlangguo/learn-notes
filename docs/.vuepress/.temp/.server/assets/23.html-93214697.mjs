import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "../app.11715a5c.mjs";
import "@vuepress/shared";
import "ts-debounce";
import "vue-router";
import "@vueuse/core";
import "vuepress-shared/client";
const _sfc_main = {};
function _sfc_ssrRender(_ctx, _push, _parent, _attrs) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h2 id="_23-前端学习踩坑史" tabindex="-1"><a class="header-anchor" href="#_23-前端学习踩坑史" aria-hidden="true">#</a> 23-前端学习踩坑史</h2><p>其实作者（李兵）早些年主要是做C/C++开发的，到了2009年，接触到了浏览器研发，这个时候作者（李兵）对前端并不是太熟悉，但是在开发浏览器的过程中，需要了解大量的前端知识。作者（李兵）当时的学习策略是，只有当遇到了与前端有关的问题时，才会去学习相应的知识来解决。这样做本意是想要节省时间，结果却反而让作者（李兵）花费了更多不必要的时间。</p><p>比如在开发双核浏览器的 Cookie 共享的过程中，作者（李兵）发现有一个例外，那就是设置了 HttpOnly 属性的 Cookie 是无法被共享的。</p><p>为了解决这个问题，作者（李兵）就去查 HttpOnly 相关概念，发现这和 Web 安全体系有关系，然后作者（李兵）就去补安全相关的知识。之后作者（李兵）又发现，浏览器多进程架构和安全系统息息相关，也就是说，这些知识是环环相扣的。</p><p>因为作者（李兵）当时对前端并没有做整体的了解，所以对浏览器中涉及到的安全相关的设计也没有过多关注。每次遇到一些和前端相关的细节问题时，作者（李兵）都需要花费很多时间去补充相关知识，然后再去解决问题，这种方式白白地浪费了作者（李兵）非常多的时间。更加遗憾的是，作者（李兵）之前积累的很多前端知识，都是这么缝缝补补学习过来的。</p><p>所以，当你要开发一个新项目或者学习一门手艺之前，应该将其所涉及到的知识做一个全方位的了解。作者（李兵）就觉得发明“技术栈”这个词的人是一个天才，“技术栈”非常形象地表达了学习一门手艺所需要的是哪些知识，以及应该按照什么顺序来学。</p><p>比如学习前端这门手艺，栈底到栈顶依次是浏览器架构、Web 网络、事件循环机制、JavaScript 核心、V8 的内存管理、浏览器的渲染流程、Web 安全、CSS、React、Vue、Node、构建工具链等，作者（李兵）们可以从栈底往栈顶一步步循序渐进地学习。</p><p>学习技术栈的每一层都不难，难的是当你抛开底层栈的内容去理解上层栈的内容，那么就有可能陷入知识点的盲区。</p><p>其实，作者（李兵）们在学习一门手艺的时候，即便没有完善的技术栈资料，只要肯花更多的时间，也可以克服困难。甚至作者（李兵）们的学习过程可以像一个无头苍蝇，横冲直撞，某一天也会突然顿悟整个知识体系 ，俗话说，在一个领域耕耘十年，必定能成为该领域的专家。</p><p>但是，三年可以搞定的事，为什么非要花上十年呢？</p><p>系统性学习一门技术，花费的时间也是最短的，也可以说是性价比最高的，因为系统性地、循序渐进地学习，那么学习到每个知识点时，其实并没有其他的知识盲区，这样学习起来是最轻松、简单的。</p><p>虽然技术栈的概念已经提出来很久了，但是作者（李兵）发现大家对技术栈的理解却不同。比如作者（李兵）们在招聘前端工程师时，经常会看到有人在简历上提到自己的技术栈包含了 Vue、React、Node 等这些偏应用的知识，在作者（李兵）看来，这并不是技术栈，这只不过是栈顶函数的上下文而已，而对于那些在技术栈底层上下文相关的知识，在简历中却很少有提及。所谓技术栈，应该是在某一领域，从底层的基础知识到上层的应用技术有一个完整体系。</p><p>那么当作者（李兵）们进入一个领域时，应该如何建立适合自己的技术栈呢？</p><p>如果你进入的是一个成熟的领域，那么一般都有比较完整的技术栈的资料，作者（李兵）们需要花些时间分析资料，系统性地了解这一领域知识的宏观架构、它的过往历史、它的优缺点，然后结合现有资料和作者（李兵）们自身的特点来建立作者（李兵）们自己的技术栈。如果你所在的领域还在高速发展中，并没有人总结出完整的技术栈，那么为了更好地理解技术的发展脉络，作者（李兵）们需要花更多一些的时间去整理出该领域的技术栈。</p><p>所以后面作者（李兵）就吸取了经验，比如作者（李兵）学习神经网络的过程中，就采取了先构建技术栈的方式，先系统性复习了微积分、概率论、线性代数，然后结合实际项目完成了数据清洗、构建模型、模型训练，最后到实际应用。整个过程作者（李兵）只花了半年时间，最后作者（李兵）对神经网络也有了非常深的认知，现在作者（李兵）们正在打算将神经网络运用到作者（李兵）们的新项目中。</p><p>采用了同样的的方法，作者（李兵）在学习区块链和数字货币时，整个过程也是非常轻松的，先分析区块链要解决什么问题，然后整理技术栈，再通过技术栈来一步步学习，不到两周，作者（李兵）基本就把整个数字货币的来龙去脉分析的非常清楚了。</p></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../pages/v8/23.html.vue");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const _23_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender], ["__file", "23.html.vue"]]);
export {
  _23_html as default
};
