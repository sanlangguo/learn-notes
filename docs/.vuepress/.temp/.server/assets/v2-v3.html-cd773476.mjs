import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "../app.0c33dd42.mjs";
import "@vuepress/shared";
import "ts-debounce";
import "vue-router";
import "@vueuse/core";
import "vuepress-shared/client";
const _sfc_main = {};
function _sfc_ssrRender(_ctx, _push, _parent, _attrs) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h3 id="vue-3与vue-2有哪些主要的区别" tabindex="-1"><a class="header-anchor" href="#vue-3与vue-2有哪些主要的区别" aria-hidden="true">#</a> Vue 3与Vue 2有哪些主要的区别？</h3><ul><li><code>Composition API：Vue 3</code>引入了<code>Composition API</code>，它提供了一种基于函数的组合式编程的方式，使得代码更加可复用和可组合。而<code>Vue 2</code>使用的是Options API。</li><li>性能优化：Vue 3在虚拟DOM的更新算法上进行了优化，提高了渲染性能。</li><li>TypeScript：Vue 3对TypeScript的支持更加友好，内置了更多的类型声明，可以提供更好的开发体验和代码提示。</li><li>包大小：Vue 3的包体积相比Vue 2更小，减少了运行时的体积。</li></ul><h3 id="vue-3中的teleport是什么-有什么作用" tabindex="-1"><a class="header-anchor" href="#vue-3中的teleport是什么-有什么作用" aria-hidden="true">#</a> Vue 3中的Teleport是什么？有什么作用？</h3><ul><li>Teleport是Vue 3中新增的一个特性，它允许你将组件的内容渲染到指定的目标位置上。 它的作用是帮助我们处理在HTML结构上需要移动的元素，并且不会打破语义化。</li></ul><p>vVue 3中的响应式系统与Vue 2有何改进？</p><ul><li>Vue 3使用Proxy代替了Vue 2中的Object.defineProperty，从而提供了更好的性能和更全面的响应式能力。</li><li>Vue 3中的响应式系统可以监听动态添加的属性。</li><li>Vue 3中的响应式系统支持了嵌套对象的深层监听。</li></ul><h3 id="vue-3中的suspense是什么-如何使用它" tabindex="-1"><a class="header-anchor" href="#vue-3中的suspense是什么-如何使用它" aria-hidden="true">#</a> Vue 3中的Suspense是什么？如何使用它？</h3><ul><li>Suspense是Vue 3中新增的一个特性，用于处理异步组件的加载状态。</li><li>使用Suspense，可以在组件树中定义一个fallback内容，当异步组件尚未加载完成时，可以显示fallback内容，提供更好的用户体验。</li><li>在Vue 3中，通过在父组件中使用<code>&lt;Suspense&gt;</code>标签包裹异步组件，并通过<code>&lt;template #default&gt;</code>来定义fallback内容，即可使用Suspense。</li></ul><h3 id="vue-3中的fragment是什么-为什么要使用它" tabindex="-1"><a class="header-anchor" href="#vue-3中的fragment是什么-为什么要使用它" aria-hidden="true">#</a> Vue 3中的Fragment是什么？为什么要使用它？</h3><ul><li>Fragment是Vue 3中新增的一个特性，允许我们在不增加额外DOM元素的情况下，渲染多个子元素。</li><li>在Vue 2中，组件的模板必须有一个根元素进行包裹，而Fragment可以帮助我们去除这个额外的包裹元素，使得组件更加简洁和灵活。</li></ul><h3 id="vue-3中的composition-api是什么-它与options-api有何不同" tabindex="-1"><a class="header-anchor" href="#vue-3中的composition-api是什么-它与options-api有何不同" aria-hidden="true">#</a> Vue 3中的Composition API是什么？它与Options API有何不同？</h3><ul><li>Composition API是Vue 3中新增的一种API风格，它基于函数的组合方式来组织组件的逻辑。 与Options API相比，Composition API更加灵活和可组合，可以将相关的逻辑组织在一起，提高代码的复用性。</li><li>Composition API使用setup()函数来替代Vue 2中的data()、methods()等选项，并且可以使用ref、reactive等函数来创建响应式数据。</li></ul><h3 id="vue-3中的proxy和reflect在响应式系统中起到了什么作用" tabindex="-1"><a class="header-anchor" href="#vue-3中的proxy和reflect在响应式系统中起到了什么作用" aria-hidden="true">#</a> Vue 3中的Proxy和Reflect在响应式系统中起到了什么作用？</h3><ul><li>Vue 3使用Proxy来实现响应式系统，它可以拦截对象上的各种操作，如属性访问、属性设置、删除等。</li><li>Proxy可以提供更全面的响应式能力，并且可以监听动态添加的属性。</li><li>Reflect是一个内置的对象，它提供了一组处理对象的默认操作方法，可以简化对Proxy的调用。</li></ul><h3 id="vue-3中的v-model指9-vue-3中的v-model指令有哪些新的特性" tabindex="-1"><a class="header-anchor" href="#vue-3中的v-model指9-vue-3中的v-model指令有哪些新的特性" aria-hidden="true">#</a> Vue 3中的v-model指9. Vue 3中的v-model指令有哪些新的特性？</h3><ul><li>在Vue 3中，v-model指令支持通过modelValue和update:modelValue来自定义组件的双向绑定。</li><li>可以使用v-model简化对表单元素的绑定，无需再使用value和@input事件。</li><li>可以使用.sync修饰符来实现子组件与父组件之间的双向数据绑定。</li></ul><h3 id="vue-3中的teleport和portal的区别是什么" tabindex="-1"><a class="header-anchor" href="#vue-3中的teleport和portal的区别是什么" aria-hidden="true">#</a> Vue 3中的Teleport和Portal的区别是什么？</h3><ul><li>Teleport是Vue 3中新增的特性，用于将组件的内容渲染到指定的目标位置上，它是一种更加灵活的替代方案。</li><li>Portal是React中的概念，在Vue中可以通过Teleport实现类似的功能，但Portal并不是Vue中内建的特性。</li></ul><h3 id="vue-3中的动态组件是如何使用的" tabindex="-1"><a class="header-anchor" href="#vue-3中的动态组件是如何使用的" aria-hidden="true">#</a> Vue 3中的动态组件是如何使用的？</h3><ul><li>在Vue 3中，可以通过<code>&lt;component&gt;</code>元素来实现动态组件的渲染。</li><li>可以使用:is属性来指定要渲染的组件类型，也可以通过v-bind动态绑定组件类型。</li></ul><h3 id="vue-3中的全局api和实例方法有哪些变化" tabindex="-1"><a class="header-anchor" href="#vue-3中的全局api和实例方法有哪些变化" aria-hidden="true">#</a> Vue 3中的全局API和实例方法有哪些变化？</h3><ul><li>在Vue 3中，全局API（如Vue.use()、Vue.directive()等）都被移除了，取而代之的是使用app.use()、app.directive()等实例方法来注册全局功能。</li></ul><h3 id="vue-3中的事件处理方式有何改变" tabindex="-1"><a class="header-anchor" href="#vue-3中的事件处理方式有何改变" aria-hidden="true">#</a> Vue 3中的事件处理方式有何改变？</h3><ul><li>在Vue 3中，事件处理函数不再自动绑定到组件实例上，需要显式地使用.bind()或箭头函数绑定。</li><li>使用事件修饰符时，需要在事件名称后面使用句点.进行分隔，如@click.stop、@keydown.enter等。</li></ul><h3 id="vue-3中的虚拟dom算法有何优化" tabindex="-1"><a class="header-anchor" href="#vue-3中的虚拟dom算法有何优化" aria-hidden="true">#</a> Vue 3中的虚拟DOM算法有何优化？</h3><ul><li>Vue 3中引入了基于Proxy的观察机制，使得虚拟DOM可以更精确地跟踪响应式数据的变化，提高了渲染性能。</li><li>Vue 3还优化了diff算法，减少了不必要的DOM操作，提高了更新效率。</li></ul><h3 id="vue-3中新增的响应式api有哪些" tabindex="-1"><a class="header-anchor" href="#vue-3中新增的响应式api有哪些" aria-hidden="true">#</a> Vue 3中新增的响应式API有哪些？</h3><ul><li>在Vue 3中，新增了一些响应式的API，包括ref、reactive、toRef、toRefs等。</li><li>ref用于创建一个单一的响应式数据，而reactive用于创建一个响应式的对象。</li><li>toRef和toRefs用于创建一个对已有响应式数据的引用。</li></ul><h3 id="vue2-和-vue3-双向绑定方法不同" tabindex="-1"><a class="header-anchor" href="#vue2-和-vue3-双向绑定方法不同" aria-hidden="true">#</a> vue2 和 vue3 双向绑定方法不同</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Vue2 : Object.defineProperty()
***后添加的属性是劫持不到的

Vue3 : new Proxy()
***即使后添加的也可以劫持到***还不需要循环
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="set在vue3中没有-因为new-proxy不需要" tabindex="-1"><a class="header-anchor" href="#set在vue3中没有-因为new-proxy不需要" aria-hidden="true">#</a> $set在vue3中没有，因为new Proxy不需要</h3><h3 id="v-if和v-for优先级不同了" tabindex="-1"><a class="header-anchor" href="#v-if和v-for优先级不同了" aria-hidden="true">#</a> v-if和v-for优先级不同了</h3><ul><li>vue2 v-for优先级高</li><li>vue3 v-if 优先级高</li></ul></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../pages/vue/v2-v3.html.vue");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const v2V3_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender], ["__file", "v2-v3.html.vue"]]);
export {
  v2V3_html as default
};
