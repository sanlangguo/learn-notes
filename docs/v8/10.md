## 10-机器代码：二进制机器码究竟是如何被CPU执行的

本文主要介绍了 CPU 如何执行二进制机器码。在此之前，我们需要了解如何将源代码编译成机器码，以及编译后的机器码如何被 CPU 执行。

将源码编译成机器码
以一段 C 代码为例，我们可以看到这段代码只是做了一个简单的加法操作，将 x 和 y 两个数字相加得到 z，并返回结果 z。

```c
int main() {
  int x = 1;
  int y = 2;
  int z = x + y;
  return z;
}
```
我们知道，CPU 并不能直接执行这段 C 代码，而是需要对其进行编译，将其转换为二进制的机器码，然后 CPU 才能按照顺序执行编译后的机器码。

我们可以通过 GCC 编译器将这段 C 代码编译成二进制文件，命令为：

```js
gcc -O0 -o code_prog code.c
```
输入命令后会在文件夹中生成名为 code_prog 的可执行程序。接下来我们再将编译后的机器码反汇编成汇编代码，以便更好地理解机器码的执行过程。

### 机器码的执行过程
机器码是由 0 和 1 组成的二进制代码，CPU 只能执行二进制代码。CPU 中有一个叫做指令寄存器（Instruction Register）的寄存器，它存储着当前要执行的指令。CPU 还有一个叫做程序计数器（Program Counter）的寄存器，它存储着下一条要执行的指令的地址。

CPU 执行机器码的过程如下：

CPU 从程序计数器中读取下一条指令的地址。
CPU 根据指令地址从内存中读取指令，并将其存储到指令寄存器中。
CPU 解析指令，并根据指令执行相应的操作。
CPU 将程序计数器加上指令的长度（通常为 1 到 15 个字节），以便读取下一条指令。
以上四个步骤会不断重复，直到程序结束或出现异常情况。

在本文示例中，编译后的机器码如下：

```c
55                      push   rbp
48 89 e5                mov    rbp,rsp
c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1
c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2
8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]
8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]
01 d0                   add    eax,edx
89 c2                   mov    edx,eax
c9                      leave
c3                      ret

```
可以看到，机器码中的每条指令都是由若干个字节组成的。例如第一条指令 55，它只有一个字节，表示将当前栈帧的基址（即 RBP）压入栈中。而第四条指令 8b 45 fc 则有三个字节，表示将 RBP - 0x4 处的值存入 EAX 寄存器中。

在本文示例中，CPU 执行机器码时首先执行第一条指令 push rbp，然后执行第二条指令 mov rbp, rsp，将当前栈帧的基址设置为栈顶地址。接下来依次执行第三至第七条指令，最后返回结果。

### 总结
本文介绍了 CPU 如何执行二进制机器码。CPU 执行机器码时需要将其从内存中读取到指令寄存器中，并解析指令并根据指令执行相应的操作。在本文示例中，我们可以看到机器码中的每条指令都是由若干个字节组成的。