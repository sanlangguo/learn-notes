## 01-V8是如何执行一段JavaScript代码的？

本文主要介绍了V8是如何执行一段JavaScript代码的。V8是一个由Google开发的开源JavaScript引擎，目前用在Chrome浏览器和Node.js中，其核心功能是执行易于人类理解的JavaScript代码。

### V8的虚拟机

可以把V8看成是一个虚构出来的计算机，也称为虚拟机，虚拟机通过模拟实际计算机的各种功能来实现代码的执行，如模拟实际计算机的CPU、堆栈、寄存器等，虚拟机还具有它自己的一套指令系统。

对于JavaScript代码来说，V8就是它的整个世界，当V8执行JavaScript代码时，你并不需要担心现实中不同操作系统的差异，也不需要担心不同体系结构计算机的差异，你只需要按照虚拟机的规范写好代码就可以了。


### 关键概念

文章还介绍了一些关键概念，如JIT、作用域、词法环境、执行上下文等。这些概念对于理解V8的工作原理和编写高效JavaScript代码非常重要。


### JIT

JIT（Just-In-Time）是V8的一个重要特性，它可以在运行时编译JavaScript代码，从而提高代码的执行效率。JIT编译器会将热点代码（被频繁执行的代码）编译成本地机器码，这样可以避免每次执行时都需要解释一遍JavaScript代码，从而提高了代码的执行速度。

### 作用域

作用域是指变量和函数的可访问范围。在JavaScript中，作用域分为全局作用域和函数作用域。全局作用域中定义的变量和函数可以在任何地方访问，而函数作用域中定义的变量和函数只能在函数内部访问。

### 词法环境

词法环境是指JavaScript代码在执行期间创建的一个环境，它包含了当前执行代码所需的所有变量和函数。每个词法环境都有一个外部引用，指向它所处的外部词法环境，这样就形成了一个词法环境链。

### 执行上下文

执行上下文是指JavaScript代码在执行期间所处的环境，它包含了当前执行代码所需的所有信息，如变量、函数、作用域等。每个执行上下文都有一个与之对应的词法环境和变量环境，它们分别保存了当前执行上下文所需的变量和函数信息。

### V8的执行流程

V8的执行流程可以分为以下几个步骤：

1. 语法分析：V8首先会对JavaScript代码进行语法分析，生成抽象语法树（AST）和词法作用域链。

1. 预编译：V8会对AST进行预编译，生成可执行的字节码，并为每个函数创建一个闭包。

1. JIT编译：当函数被多次调用时，V8会将其字节码编译成本地机器码，并将其存储在代码缓存中，以便下次调用时直接使用。

1. 执行：V8会按照字节码或本地机器码的顺序执行代码，并输出执行结果。

### 结论

本文通过对V8的介绍和执行过程的详细解释，让读者对V8的执行流程有了整体上的认识，并且了解了一些关键概念，帮助读者更好地理解V8是如何工作的，同时也能够帮助读者写出更加高效的JavaScript代码。

## 02-函数即对象：一篇文章彻底搞懂JavaScript的函数特点

本文对JavaScript中的函数特点进行了深入分析，主要包括以下内容：

### 函数是一等公民

JavaScript中的函数是一种特殊的对象，被称为“一等公民”，这使得JavaScript非常灵活，容易实现一些特性，比如闭包和函数式编程。

### 对象和面向对象

在JavaScript中，大部分内容都是由对象构成的，包括函数和数组等。JavaScript是基于对象的语言，但与其他面向对象语言不同，它是基于原型(prototype)而不是类(class)的。

### 函数的特点

JavaScript中的函数具有以下特点：

1. 可以像普通变量一样被赋值和传递
1. 可以作为参数传递给其他函数
1. 可以作为其他函数的返回值
1. 可以在运行时动态地创建和修改
1. 闭包和函数式编程
1. 由于JavaScript中的函数是一等公民，因此可以很容易地实现闭包和函数式编程。本文对这两个特性进行了简要介绍，并指出它们在实际项目中的重要性。

### 闭包的实现

闭包是指函数可以访问其词法作用域外的变量。在JavaScript中，闭包的实现需要同时考虑到函数作用域和词法作用域，这就需要引擎在运行时动态地创建并维护一个作用域链。

V8引擎在实现闭包时，会将函数和其所在的词法作用域打包成一个闭包对象，这个对象会被存储在堆内存中。在函数执行时，V8引擎会根据作用域链查找变量的值，如果变量在当前作用域中不存在，则会逐级向上查找，直到找到为止。

### 加速JavaScript代码执行

V8引擎在加速JavaScript代码执行方面主要采用了以下两种技术：

### JIT编译

JIT(即时编译)是指将JavaScript代码在运行时动态地编译成机器码，从而提高代码的执行速度。V8引擎采用了一种称为“热点代码优化”的技术，它会对频繁执行的代码进行优化，将其编译成高效的机器码。

### 隐藏类

隐藏类是一种将JavaScript对象映射到内存中的数据结构，它可以提高对象属性的访问速度。V8引擎通过动态生成隐藏类来优化对象属性的访问，从而提高代码的执行速度。


### V8引擎

本文还提到了V8引擎，介绍了它是如何实现闭包和加速JavaScript代码执行的。

通过本文的阅读，读者可以深入了解JavaScript中函数的特点和底层机制，提高自己的代码编写能力。

总的来说，V8引擎通过闭包的实现和加速JavaScript代码执行来提高代码的性能，从而为Chrome浏览器和Node.js等应用提供了更好的用户体验。

## 03-快属性和慢属性：V8是怎样提升对象属性访问速度的

在本文中，作者介绍了 V8 引擎是如何提升 JavaScript 对象属性访问速度的。V8 引擎在实现对象存储时，并没有完全采用字典的存储方式，这是出于性能的考量。因为字典是非线性的数据结构，查询效率会低于线性的数据结构。因此，V8 引擎采用了一套复杂的存储策略。

### 常规属性和排序属性

在 JavaScript 中，对象由一组组属性和值的集合组成，JavaScript 对象像一个字典，字符串作为键名，任意对象可以作为键值，可以通过键名读写键值。然而，在 V8 实现对象存储时，并没有完全采用字典的存储方式。V8 引擎采用了常规属性和排序属性两种存储方式。

常规属性是指键名为整数的属性，排序属性是指键名为字符串的属性。在 V8 引擎中，常规属性和排序属性分别采用不同的存储方式。常规属性使用元素表存储，排序属性使用属性字典存储。

### 快属性和慢属性

在 V8 引擎中，对象的属性被分为快属性和慢属性两种类型。快属性是指可以在元素表或属性字典中直接访问的属性，访问速度非常快。慢属性是指无法直接访问的属性，需要通过查找原型链或执行 getter 函数才能访问，访问速度较慢。

### 隐藏类

在 V8 引擎中，每个对象都对应一个隐藏类，隐藏类记录了对象的结构信息。当一个新对象被创建时，V8 引擎会根据对象的结构信息创建一个对应的隐藏类，并将该对象与该隐藏类关联起来。如果一个新对象的结构与已有对象相同，则该新对象会与已有对象共享同一个隐藏类。

### 总结

通过采用常规属性、排序属性、快属性、慢属性和隐藏类等技术手段，V8 引擎实现了高效的对象存储和访问。这些优化措施使得 V8 引擎成为目前最快的 JavaScript 引擎之一。

## 04-函数表达式：涉及大量概念，函数表达式到底该怎么学

本文介绍了JavaScript中函数表达式的重要性和应用，以及学习函数表达式所需要理解的底层概念。函数表达式在JavaScript中非常基础也非常重要，使用函数表达式可以用来实现代码隐藏，还可以实现变量隔离，因此被广泛地应用在各个项目中。

### 函数表达式的学习难度

虽然函数表达式在JavaScript中非常基础也非常重要，但是学好函数表达式并不容易。因为它涉及到了很多底层概念，比如表达式、语句、函数即对象（在JavaScript中）等。而且函数表达式和函数声明看起来类似，都是定义一个函数，然后再调用该函数，很容易把二者搞混淆了。

### 函数声明与函数表达式的差异

实际上，函数表达式和函数声明有着本质上的差异。理解了这种差异，你对函数表达式的理解也就加深了。

首先，我们来看一段代码：

```js

foo()

function foo(){

console.log('foo')

}

```

在这段代码中，我们声明了一个foo函数，然后在foo函数之前调用了foo函数。执行这段代码，我们发现foo函数被正确执行了。这是因为在JavaScript中，函数声明会被提升到作用域的顶部，所以在声明之前就可以调用该函数。

接下来，我们再来看一段代码：

```js

foo()

var foo = function (){

console.log('foo')

}

```

在这段代码中，我们定义了一个变量foo，并将一个函数赋值给了变量foo。同样在源码中，我们也是在foo函数的前面调用foo。执行这段代码，我们发现报错了，提示变量foo并不是一个函数。

这是因为在JavaScript中，变量声明也会被提升到作用域的顶部，但是变量的赋值操作并不会被提升。因此，在第一次调用foo时，变量foo还没有被赋值为一个函数，所以会报错。

### 总结

本文介绍了JavaScript中函数表达式的重要性和应用，以及学习函数表达式所需要理解的底层概念。同时，本文还通过比较函数声明和函数表达式的差异，帮助读者更好地理解它们之间的区别。

## 05-原型链：V8是如何实现对象继承的

本文介绍了JavaScript中的继承机制，其中主要介绍了基于类的继承和基于原型的继承两种方式。

### 基于类的继承

C++、Java、C#等语言都是基于类的继承方式。这种方式提供了复杂的规则和关键字，如class、friend、protected、private、interface等，通过组合使用这些关键字，可以实现继承。

但是，使用基于类的继承时，如果业务复杂，需要创建大量的对象，并需要维护复杂的继承关系，导致代码过度复杂和臃肿。此外，引入了大量关键字也增加了设计复杂度。

### 基于原型的继承

JavaScript中的继承方式和其他面向对象的继承方式有所不同。JavaScript本身不提供class实现。虽然ES2015/ES6中引入了class关键字，但这只是语法糖，JavaScript的继承仍然和基于类的继承没有任何关系。

JavaScript仅仅在对象中引入了一个原型属性，就实现了语言的继承机制。基于原型的继承省去了很多基于类继承时的繁文缛节，简洁而优美。

在JavaScript中，每个对象都有一个原型对象，该对象包含可共享的属性和方法。如果在对象自身找不到属性或方法，则会在原型对象中查找。原型对象也有自己的原型对象，从而形成了一个原型链。

V8引擎使用了一种称为隐藏类的技术来实现对象继承。当创建一个新对象时，V8会为该对象创建一个隐藏类，该类包含该对象的所有属性和方法。如果新对象与已有对象具有相同的属性和方法，则它们将共享相同的隐藏类。

- 隐藏类技术

隐藏类技术是一种为 JavaScript 对象分配内存的方法，它可以提高 JavaScript 代码的执行效率。在 JavaScript 中，每个对象都有一个隐藏类，它描述了对象的属性名和属性值的对应关系。当一个新对象被创建时，V8 引擎会根据对象的属性名和属性值来创建一个隐藏类，并为该对象分配内存。如果另一个对象具有相同的属性名和属性值，则它们将共享同一个隐藏类和相同的内存结构。这样可以减少内存的使用，并提高代码的执行效率。

当对象的属性发生变化时，V8 引擎会根据新的属性名和属性值创建一个新的隐藏类，并为该对象重新分配内存。由于重新分配内存会导致性能下降，因此在编写 JavaScript 代码时应尽量避免频繁地修改对象的属性。

当一个对象被修改时，V8会创建一个新的隐藏类，并将该对象与新隐藏类相关联。如果一个新属性被添加到该对象中，则V8会创建一个新隐藏类，并将该属性添加到该类中。

### 总结

JavaScript中的继承方式是基于原型的，省去了基于类继承时的繁文缛节，简洁而优美。每个对象都有一个原型对象，通过原型链查找属性和方法。V8引擎使用隐藏类技术实现对象继承，当创建新对象时会为其创建一个隐藏类，如果新对象与已有对象具有相同的属性和方法，则它们将共享相同的隐藏类。

06-作用域链：V8是如何查找变量的

作用域链

作用域链是将一个个作用域串起来，实现变量查找的路径。每个函数都有自己的作用域，函数作用域中存放了函数中定义的变量。当在函数内部使用一个变量时，V8便会去作用域链中查找。

变量查找路径

当在函数内部使用一个变量时，V8会按照以下顺序查找：

1. 查找当前函数作用域中是否有该变量，如果有则直接使用。
1. 如果当前函数作用域中没有该变量，则去上一级作用域中查找，直到找到该变量或者到达全局作用域。
1. 如果在全局作用域中都没有找到该变量，则会报错。

构建作用域链

在执行函数时，V8会构建一个作用域链。具体构建过程如下：

1. 创建当前函数的执行环境。
1. 将当前函数的活动对象添加到执行环境中。
1. 将当前函数的活动对象添加到作用域链的最前端。
1. 将外部函数的活动对象添加到作用域链中。
1. 将全局执行环境的变量对象添加到作用域链中。

示例

当在函数内部使用一个变量时，V8会按照以下顺序查找：

1. 查找当前函数作用域中是否有该变量，如果有则直接使用。
1. 如果当前函数作用域中没有该变量，则去上一级作用域中查找，直到找到为止。
1. 如果最终仍然没有找到该变量，则会报错。

以下是一个具体的例子：

var name = '极客时间';

var type = 'global';

function foo(){

`  `var name = 'foo';

`  `console.log(name);

`  `console.log(type);

}

function bar(){

`  `var name = 'bar';

`  `var type = 'function';

`  `foo();

}

bar();

在这个例子中，我们在全局环境中声明了变量name和type，同时还定义了bar函数和foo函数，在bar函数中又再次定义了变量name和type，在foo函数中再次定义了变量name。

当执行到foo函数时，首先需要打印出变量name的值，而我们在三个地方都定义了变量name，那么究竟应该使用哪个变量呢？

在foo函数中使用了变量name，那么V8就应该先使用foo函数内部定义的变量name，最终的结果确实如此，也符合我们的直觉。

接下来，foo函数继续打印变量type，但是在foo函数内部并没有定义变量type，而是在全局环境中和调用foo函数的bar函数中分别定义了变量type，那么这时候的问题来了，你觉得foo函数中打印出来的变量type是bar函数中的，还是全局环境中的呢？答案是全局环境中的。因为在foo函数内部没有找到变量type，所以V8会去上一级作用域（即全局作用域）中查找，最终找到了全局环境中定义的变量type。

## 07-类型转换：V8是怎么实现1-“2”的

本文主要讲解 JavaScript 中的类型系统，探讨在 JavaScript 中让数字和字符串相加是会报错，还是可以正确执行，以及相加后的结果是数字还是字符串的问题。

### 问题引入

在 JavaScript 中，“1+‘2’等于多少？”这个问题，实际上是在问，让数字和字符串相加是会报错，还是可以正确执行。如果能正确执行，那么结果是等于数字3，还是字符串“3”，还是字符串“12”呢？

###  类型系统

要想理清以上问题，我们需要了解类型的概念，以及 JavaScript 操作类型的策略。

在机器语言中，所有的数据都是一堆二进制代码，CPU 处理这些数据的时候，并没有类型的概念，CPU 所做的仅仅是移动数据，比如对其进行移位、相加或相乘。

而在高级语言中，我们都会为操作的数据定义类型。类型系统就是一套规则，用于定义程序中所有可能存在的类型，并规定了这些类型之间可以进行哪些运算。

JavaScript 中的类型系统是动态类型系统，也就是说，变量的类型是在运行期间确定的。这意味着，在 JavaScript 中，同一个变量在不同的时间内可能会存储不同类型的值。

### 类型转换

在 JavaScript 中，有两种类型转换：隐式类型转换和显式类型转换。

隐式类型转换就是在运行期间自动发生的类型转换。例如，当我们对数字和字符串进行相加操作时，JavaScript 引擎会自动将数字转换为字符串，并将两个字符串拼接起来。

显式类型转换就是我们在代码中直接指定要进行类型转换。例如，我们可以使用 Number() 函数将字符串转换为数字。

### 问题解答

回到最初的问题：“1+‘2’等于多少？”在 JavaScript 中执行这段表达式，会返回字符串“12”。

这是因为，在 JavaScript 中进行加法运算时，如果其中一个操作数是字符串类型，那么 JavaScript 引擎会将另一个操作数也转换为字符串类型，并将两个字符串拼接起来。

所以，在这个例子中，数字 1 被转换为字符串 "1"，然后与字符串 "2" 进行拼接，得到了结果 "12"。

### 总结

JavaScript 中的类型系统是动态类型系统，在运行期间确定变量的类型。

JavaScript 中有两种类型转换：隐式类型转换和显式类型转换。

当进行加法运算时，如果其中一个操作数是字符串类型，那么 JavaScript 引擎会将另一个操作数也转换为字符串类型，并将两个字符串拼接起来。

## 08-如何构建和使用V8的调试工具d8

本文主要介绍如何构建和使用V8的调试工具d8，d8可以用来查看V8在执行JavaScript过程中的各种中间数据，包括作用域、AST、字节码、优化的二进制代码、垃圾回收的状态等，并可以使用d8提供的私有API查看一些内部信息。

### 构建d8

要构建d8，需要先下载V8的源码并生成工程文件，然后再编译V8的工程并生成d8。具体步骤如下：

1. 下载V8的源码，需要使用VPN；
1. 下下载编译工具链depot\\_tools，并将其解压到本地路径中，并将该路径添加到环境变量中；
1. 下在系统环境变量中添加变量DEPOT\\_TOOLS\\_WIN\\_TOOLCHAIN，值设为0；
1. 下使用gclient下载V8源码；
1. 下使用gn生成工程文件；
1. 下使用ninja编译生成d8。


### 使用d8

使用d8可以查看V8在执行JavaScript过程中的各种中间数据，包括作用域、AST、字节码、优化的二进制代码、垃圾回收的状态等，并可以使用d8提供的私有API查看一些内部信息。具体步骤如下：

### 运行d8命令，进入d8的交互式环境；

1. 下使用--help命令查看d8支持的参数和命令；
1. 下使用--print-ast命令打印JavaScript代码的AST（抽象语法树）；
1. 下使用--print-bytecode命令打印JavaScript代码的字节码；
1. 下使用--print-opt-code命令打印JavaScript代码的优化二进制代码；
1. 下使用--trace-gc命令跟踪垃圾回收状态；
1. 下使用--allow-natives-syntax命令调用V8的私有API查看一些内部信息。


### 总结

本文介绍了如何构建和使用V8的调试工具d8，通过d8可以查看V8在执行JavaScript过程中的各种中间数据，并可以使用d8提供的私有API查看一些内部信息。

## 09-运行时环境：运行JavaScript代码的基石


本文主要介绍V8的运行时环境和宿主环境。

### 运行时环境

在执行JavaScript代码之前，V8会先准备好代码的运行时环境，包括堆空间和栈空间、全局执行上下文、全局作用域、内置的内建函数、宿主环境提供的扩展函数和对象，以及消息循环系统。了解运行时环境可以帮助我们更好地理解V8的执行流程。

### 宿主环境

V8的宿主环境是指V8被嵌入到的应用程序或环境。在宿主环境中，V8可以使用宿主环境提供的扩展函数和对象，比如在浏览器中，V8可以使用window对象和DOM API。宿主环境还可以向V8提供一些回调函数，比如在Node.js中，可以使用process.nextTick()函数进行异步操作。

了解宿主环境可以帮助我们更好地使用V8，并且在不同的宿主环境中，V8的使用方式也会有所不同。

总之，了解运行时环境和宿主环境对我们理解V8的执行流程和使用V8都非常重要。

## 10-机器代码：二进制机器码究竟是如何被CPU执行的

本文主要介绍了 CPU 如何执行二进制机器码。在此之前，我们需要了解如何将源代码编译成机器码，以及编译后的机器码如何被 CPU 执行。

将源码编译成机器码

以一段 C 代码为例，我们可以看到这段代码只是做了一个简单的加法操作，将 x 和 y 两个数字相加得到 z，并返回结果 z。

```c

int main() {

int x = 1;

int y = 2;

int z = x + y;

return z;

}

```

我们知道，CPU 并不能直接执行这段 C 代码，而是需要对其进行编译，将其转换为二进制的机器码，然后 CPU 才能按照顺序执行编译后的机器码。

我们可以通过 GCC 编译器将这段 C 代码编译成二进制文件，命令为：

```js

gcc -O0 -o code\\_prog code.c

```

输入命令后会在文件夹中生成名为 code\\_prog 的可执行程序。接下来我们再将编译后的机器码反汇编成汇编代码，以便更好地理解机器码的执行过程。

### 机器码的执行过程

机器码是由 0 和 1 组成的二进制代码，CPU 只能执行二进制代码。CPU 中有一个叫做指令寄存器（Instruction Register）的寄存器，它存储着当前要执行的指令。CPU 还有一个叫做程序计数器（Program Counter）的寄存器，它存储着下一条要执行的指令的地址。

- 指令寄存器

一种用于存储当前执行指令的寄存器。在 V8 引擎中，每个 JavaScript 函数都有自己的指令寄存器，它用于存储当前执行的指令。当函数被调用时，V8 引擎会将指令寄存器初始化为函数的第一条指令，并从该位置开始执行函数体中的代码。在函数执行过程中，指令寄存器会不断更新，以便执行下一条指令

- 程序计数器

一种用于记录当前执行位置的计数器。在 V8 引擎中，程序计数器用于记录当前执行的指令在函数体中的位置。当函数被调用时，程序计数器会初始化为 0，并从函数体的第一条指令开始执行。在函数执行过程中，程序计数器会不断递增，以便执行下一条指令

CPU 执行机器码的过程如下：

CPU 从程序计数器中读取下一条指令的地址。

CPU 根据指令地址从内存中读取指令，并将其存储到指令寄存器中。

CPU 解析指令，并根据指令执行相应的操作。

CPU 将程序计数器加上指令的长度（通常为 1 到 15 个字节），以便读取下一条指令。

以上四个步骤会不断重复，直到程序结束或出现异常情况。

在本文示例中，编译后的机器码如下：

```c

55                      push   rbp

48 89 e5                mov    rbp,rsp

c7 45 fc 01 00 00 00    mov    DWORD PTR [rbp-0x4],0x1

c7 45 f8 02 00 00 00    mov    DWORD PTR [rbp-0x8],0x2

8b 45 fc                mov    eax,DWORD PTR [rbp-0x4]

8b 55 f8                mov    edx,DWORD PTR [rbp-0x8]

01 d0                   add    eax,edx

89 c2                   mov    edx,eax

c9                      leave

c3                      ret

```

可以看到，机器码中的每条指令都是由若干个字节组成的。例如第一条指令 55，它只有一个字节，表示将当前栈帧的基址（即 RBP）压入栈中。而第四条指令 8b 45 fc 则有三个字节，表示将 RBP - 0x4 处的值存入 EAX 寄存器中。

在本文示例中，CPU 执行机器码时首先执行第一条指令 push rbp，然后执行第二条指令 mov rbp, rsp，将当前栈帧的基址设置为栈顶地址。接下来依次执行第三至第七条指令，最后返回结果。

### 总结

本文介绍了 CPU 如何执行二进制机器码。CPU 执行机器码时需要将其从内存中读取到指令寄存器中，并解析指令并根据指令执行相应的操作。在本文示例中，我们可以看到机器码中的每条指令都是由若干个字节组成的。

## 11-堆和栈：函数调用是如何影响到内存布局的


本文从函数特性入手，延伸出通用的函数调用模型，分析不同的函数调用方式如何影响运行时内存布局。

### 栈结构管理函数调用

栈是一种后进先出的数据结构，用于管理函数调用。当一个函数被调用时，CPU 会在栈中为该函数分配一段内存空间，称为栈帧。栈帧中包含了该函数的参数、局部变量、返回地址等信息。当函数执行完毕后，CPU 会将该函数的栈帧出栈，恢复上一个函数的执行。

使用栈结构管理函数调用的好处在于：

1. 简单高效：栈的结构非常简单，入栈和出栈操作非常快速。
1. 空间利用率高：由于栈是后进先出的结构，因此可以很好地利用内存空间。
1. 堆结构管理动态内存分配
1. 堆是一种动态内存分配方式，用于管理应用程序的动态内存。堆中的内存空间不会自动释放，需要手动进行释放。

使用堆结构管理动态内存分配的好处在于：

1. 灵活性高：堆中的内存空间可以根据需要进行动态分配和释放。
1. 内存空间大：由于堆中的内存空间不会自动释放，因此可以利用更多的内存空间。
1. 函数调用对内存布局的影响
1. 不同的函数调用方式会影响运行时内存布局，从而影响代码的执行逻辑。

例如，以下三段代码的底层执行逻辑是不同的：

1. 在同一个任务中重复调用嵌套的函数；
1. 使用 setTimeout 让函数在不同的任务中执行；
1. 在同一个任务中执行函数，但不是嵌套执行。
1. 第一段代码会造成栈溢出的错误，第二段代码能够正确执行，而第三段代码没有栈溢出错误，但会造成页面卡死。这是因为这三段代码在执行时所使用的内存布局不同。

### 总结

本文介绍了使用栈结构管理函数调用和使用堆结构管理动态内存分配的优点，并分析了不同的函数调用方式对运行时内存布局的影响。了解这些内容可以帮助我们更好地理解 JavaScript 的执行机制，从而编写出更高效、更可靠的代码。

## 12-延迟解析：V8是如何实现闭包的

本文主要介绍了V8引擎如何实现惰性解析，以及惰性解析如何支持JavaScript中的闭包。

### V8引擎的编译和执行阶段

V8引擎的执行过程分为编译和执行两个阶段。编译阶段将JavaScript代码转换为字节码或者二进制机器代码，而执行阶段则是指解释器解释执行字节码或者CPU直接执行机器代码。

### 惰性解析的原因

V8引擎采用惰性解析的方式，即在编译过程中并不会一次性将所有JavaScript代码转换为中间代码。这是为了避免编译时间过长和内存占用过多的问题。当解析器遇到函数声明时，会跳过函数内部代码，仅生成顶层代码的AST和字节码。

### 惰性解析的过程

文章通过一个例子来说明惰性解析的过程。当解析器遇到函数声明时，会将其转换为函数对象，并在顶层代码的AST和字节码中记录该函数的位置。当函数被调用时，解释器会检查该函数是否已经被解析，如果没有则进行解析并生成相应的AST和字节码。

### 惰性解析支持闭包

闭包是JavaScript中非常重要的特性，而惰性解析恰好支持闭包的实现。当一个函数内部定义了一个函数并返回该函数时，闭包就产生了。V8引擎通过惰性解析和作用域链来实现闭包。

### 总结

本文介绍了V8引擎如何实现惰性解析，并通过一个例子详细说明了惰性解析的过程。同时，文章也说明了惰性解析如何支持闭包的实现。

## 13-字节码（一）：V8为什么又重新引入字节码

本文介绍了V8引擎的编译流水线，以及字节码在其中的作用。V8引擎在执行JavaScript代码之前，需要将其编译为字节码，然后再解释执行字节码或者将字节码编译为二进制代码然后再执行。

### 早期V8引擎的执行流程

早期的V8引擎采用了直接将JavaScript代码编译为机器代码的方式，其执行流程如下：

将JavaScript代码转换为抽象语法树(AST)。

基线编译器将抽象语法树编译为未优化过的机器代码。

V8直接执行这些未优化过的机器代码。

如果V8检测到某段代码重复执行的概率过高，那么V8会将该段代码标记为HOT。

标记为HOT的代码会被优化编译器优化为执行效率更高的机器代码。

引入字节码的原因

早期的V8引擎中，将JavaScript代码直接编译为机器代码虽然能够提高执行效率，但是编译时间长且内存占用高，不利于代码的快速启动和运行。因此，V8团队重新引入了字节码作为中间代码，以提高启动速度和降低内存占用。

### 字节码的作用

在新版的V8引擎中，字节码有两个作用：

### 解释器可以直接解释执行字节码。

优化编译器可以将字节码编译为二进制代码，然后再执行二进制机器代码。

### 总结

本文介绍了早期V8引擎和新版V8引擎的执行流程，并介绍了字节码在其中的作用。新版V8引擎重新引入字节码作为中间代码，以提高启动速度和降低内存占用。

## 14-字节码（二）：解释器是如何解释执行字节码的

本文介绍了V8引擎中字节码的解释执行过程。在执行JavaScript代码之前，V8会将代码解析为抽象语法树(AST)和作用域信息，并将其输入到Ignition解释器中，生成字节码。然后，字节码由Ignition解释器解释执行。

### 生成字节码

当V8执行一段JavaScript代码时，会先对JavaScript代码进行解析(Parser)，并生成为AST和作用域信息，之后AST和作用域信息被输入到一个称为Ignition的解释器中，并将其转化为字节码。

解释器的执行过程

以以下代码为例：

```js

function add(x, y) {

var z = x + y;

return z;

}

console.log(add(1, 2));

```

V8首先将函数的源码解析为AST，将其转换为字节码，再由Ignition解释器解释执行。

在执行过程中，Ignition解释器会对每一条字节码指令进行解释，并根据指令类型执行相应的操作。例如，在上面的代码中，Ignition解释器会先创建一个变量z，并将x和y相加的结果赋值给z，然后将z返回。

### 字节码的优势

相较于直接将JavaScript代码编译为机器代码的方式，使用字节码有以下优势：

1. 更快的启动时间：生成字节码比直接编译为机器代码更快，因此可以更快地启动应用程序。
1. 更好的内存管理：字节码可以更好地管理内存，减少内存泄漏和内存溢出的风险。
1. 更好的可移植性：字节码可以在不同平台上运行，因此可以更好地支持跨平台应用程序。


### 总结

本文介绍了V8引擎中字节码的解释执行过程。通过了解字节码的生成和解释执行过程，可以更好地理解JavaScript运行时的内存结构和闭包的结构，同时也可以更好地优化JavaScript应用程序的性能。

## 15-隐藏类：如何在内存中快速查找对象属性

本文介绍了V8引擎中的隐藏类机制，以及它如何优化对象属性访问速度。

### 为什么静态语言的效率更高？

与静态语言相比，JavaScript是一种动态语言，这意味着对象的属性在运行时可以被修改。因此，当V8使用一个对象时，它并不知道该对象的形状，也就是不知道该对象中是否有某个属性，也不知道该属性相对于对象的偏移量是多少。因此，在JavaScript中查询对象属性时，需要按照一定规则逐步查询，这个过程非常缓慢。

相比之下，静态语言在声明一个对象之前需要定义该对象的结构，也就是形状。这种静态定义的方式可以让编译器在编译时就知道每个对象的形状和属性偏移量，从而使得对象属性访问速度更快。

### 隐藏类

为了优化JavaScript中对象属性的访问速度，V8引入了隐藏类机制。当V8使用一个新对象时，会根据该对象的属性名和属性值生成一个隐藏类，并将该隐藏类与新对象关联起来。当使用该对象时，V8会根据该对象的隐藏类来确定该对象的形状和属性偏移量，从而加快对象属性的访问速度。

### 隐藏类的生成和转换

当V8第一次使用一个新对象时，会根据该对象的属性名和属性值生成一个新的隐藏类，并将该隐藏类与新对象关联起来。当该对象的属性发生变化时，V8会生成一个新的隐藏类，并将该隐藏类与该对象关联起来。如果两个对象具有相同的隐藏类，则它们具有相同的形状和属性偏移量。

当一个对象的属性被删除时，V8会将该对象与其隐藏类分离，并将其关联到一个新的隐藏类上。如果一个新对象与之前的某个对象具有相同的属性名和属性值，则它们可以共享相同的隐藏类。如果两个隐藏类之间存在转换路径，则它们可以相互转换。

### 隐藏类的应用

通过使用隐藏类机制，V8可以大大提高JavaScript中对象属性的访问速度。此外，V8还使用内联缓存来进一步优化属性访问速度。内联缓存可以缓存最近使用的隐藏类和对应的属性偏移量，从而加快后续访问该属性时的速度。

### 总结

隐藏类机制是V8引擎中优化JavaScript对象属性访问速度的重要手段。通过使用隐藏类机制，V8可以在运行时确定每个对象的形状和属性偏移量，从而加快对象属性访问速度。同时，V8还使用内联缓存来进一步优化属性访问速度。

## 16-V8是怎么通过内联缓存来提升函数执行效率的

本文主要介绍了 V8 是如何通过内联缓存（Inline Cache，IC）来提高函数执行效率的。在 V8 中，获取对象属性值的流程是查找对象的隐藏类，根据隐藏类查找属性偏移量，再根据偏移量获取属性值，这个过程需要重复执行。为了提高效率，V8 使用内联缓存技术来缓存对象属性值的查找结果，从而减少重复查找的次数。

### 什么是内联缓存？

内联缓存是一种加速函数执行的策略。在 V8 执行函数的过程中，会观察函数中的调用点（CallSite）上的关键中间数据，并将这些数据缓存起来。当下次再次执行该函数时，V8 就可以直接利用这些中间数据，节省了再次获取这些数据的过程。因此，V8 利用内联缓存可以有效提升一些重复代码的执行效率。

为每个函数维护一个反馈向量（FeedBack Vector），反馈向量记录了函数在执行过程中的一些关键中间数据。反馈向量是一个表格，其中每一行对应一个调用点，每一列对应一个隐藏类。当函数被调用时，V8 会根据调用点和参数类型来确定隐藏类，然后查找反馈向量中对应的行和列，如果找到了缓存，则直接使用缓存中的结果；如果没有找到，则进行正常的查找过程，并将结果添加到反馈向量中。

### 内联缓存的优化策略

V8 使用了多种优化策略来提高内联缓存的效率。

### 基于类型的内联缓存

基于类型的内联缓存是最简单、最常用的一种优化策略。在 V8 中，每个对象都有一个隐藏类，V8 可以根据隐藏类来确定对象的属性偏移量和类型信息。当函数被调用时，V8 会根据参数类型来确定隐藏类，并将这个隐藏类作为关键中间数据缓存在反馈向量中。下次再次执行该函数时，如果参数类型相同，则可以直接使用缓存中的隐藏类信息。

### 基于形状的内联缓存

基于形状的内联缓存是一种更加高级的优化策略。在 V8 中，每个隐藏类都有一个形状（Shape），形状是隐藏类的元信息，描述了隐藏类中包含哪些属性和方法。当对象添加或删除属性时，V8 会创建一个新的隐藏类和新的形状。基于形状的内联缓存可以利用这个特性，在对象添加或删除属性时更新缓存。

### 基于 Map 的内联缓存

基于 Map 的内联缓存是一种更加高级、更加灵活的优化策略。在 V8 中，Map 是一种可以动态添加属性和方法的对象类型。基于 Map 的内联缓存可以利用 Map 的动态特性，在运行时动态创建新的 Map 和新的隐藏类，并将它们作为关键中间数据缓存在反馈向量中。

### 总结

本文介绍了 V8 是如何通过内联缓存来提高函数执行效率的。内联缓存是一种加速函数执行的策略，它可以缓存函数执行过程中的关键中间数据，从而减少重复查找的次数。V8 使用了多种优化策略来提高内联缓存的效率，包括基于类型、基于形状和基于 Map 的内联缓存。

## 17-消息队列：V8是怎么实现回调函数的


本文主要介绍了回调函数的概念以及V8是如何实现回调函数的。回调函数是指在调用API时需要传入的函数，用于处理执行结果。本文介绍了同步回调和异步回调的区别，以及它们在执行过程中的不同表现。

### 什么是回调函数？

回调函数是一种函数，具有函数的所有特征，包括参数和返回值。不同之处在于，回调函数需要作为参数传递给另一个函数，然后在该函数内部或宿主环境中被调用。回调函数有两种形式：同步回调和异步回调。同步回调函数在执行函数内部被执行，而异步回调函数则在执行函数外部被执行。

### V8如何实现回调函数？

V8引擎使用消息队列来实现回调函数。当我们调用API时，会将回调函数添加到消息队列中。当主线程空闲时，V8引擎会从消息队列中取出一个回调函数，并将其作为任务加入到主线程的任务队列中。主线程会依次执行任务队列中的任务，从而执行回调函数。

在执行任务队列中的任务时，如果遇到耗时的操作，例如I/O操作或者计时器等待，V8引擎会将这些操作交给其他线程或进程来处理。当这些操作完成后，V8引擎会将对应的回调函数添加到消息队列中，等待主线程空闲时执行。

### 总结

通过本文的介绍，我们了解了回调函数的概念以及V8引擎是如何实现回调函数的。了解这些内容可以帮助我们更好地理解浏览器中的Web API工作原理，以及宏任务和微任务之间的区别。同时，它也是理解异步编程模型async/await的基础。

## 18-异步编程（一）：V8是如何实现微任务的

本文主要介绍了 JavaScript 中的宏任务和微任务以及 V8 是如何实现微任务的。在 JavaScript 中，宏任务是指消息队列中的等待被主线程执行的事件，而微任务是需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。微任务可以在实时性和效率之间做一个有效的权衡，并且使用微任务可以改变现有的异步编程模型，使得可以使用同步形式的代码来编写异步调用。

### V8 如何实现微任务？

V8 是 JavaScript 的引擎之一，它通过事件循环机制来实现微任务。具体来说，V8 会在每个宏任务执行结束时，检查是否存在微任务，如果存在，则会按照添加顺序依次执行这些微任务，直到所有微任务执行完毕，才会开始执行下一个宏任务。在执行微任务时，V8 会优先处理 Promise 的回调函数，然后是 MutationObserver 和其他微任务。

### 微任务的优势

相对于宏任务，微任务具有以下优势：

精度更高：由于微任务是在主函数结束后、当前宏任务结束前执行的，因此可以更准确地控制异步操作的执行时机。

可以使用同步形式的代码编写异步调用：使用 Promise 等技术可以使异步操作的代码看起来更像同步代码。

可以避免出现“回调地狱”：使用 Promise 等技术可以避免出现多层嵌套的回调函数，使代码更易于阅读和维护。

### 知识点

微任务是基于消息队列、事件循环、UI主线程还有堆栈而来的，然后基于微任务，又可以延伸出协程、Promise、Generator、await/async等现代前端经常使用的一些技术。理解这些技术之间的关系和作用可以帮助开发者更好地理解和应用异步编程技术。

## 19-异步编程（二）：V8是如何实现async-await的

本文主要介绍了 JavaScript 中的异步编程和回调地狱问题，并介绍了解决回调地狱问题的方案，包括 Promise、Generator 和 Async/await。最后，文章详细阐述了 V8 引擎是如何实现 Async/await 的。

### JavaScript 异步编程和回调地狱问题

JavaScript 是基于单线程设计的，因此在处理大量的异步操作时，会出现回调地狱的问题，降低代码的可读性。回调地狱是指多层嵌套的回调函数，造成代码难以维护和理解。为了解决这个问题，JavaScript 社区推出了一系列的方案。

### 解决回调地狱问题的方案

Promise

Promise 是一个异步操作的容器，可以在异步操作完成后执行相应的操作。Promise 通过链式调用 then 方法来解决回调地狱问题，使得代码更加清晰易懂。

Generator 和 co

Generator 是 ES6 中新增的一种类型，可以通过 yield 关键字来实现异步操作。co 是一个库，可以将 Generator 函数自动执行，并且将 yield 关键字后面的异步操作转化为 Promise。

### sync/await

Async/await 是 ES7 中新增的一种异步编程方式。Async/await 可以将异步操作转化为同步形式的代码，使得代码更加简洁易读。

### V8 引擎如何实现 Async/await

V8 引擎是 JavaScript 的引擎之一，它通过协程（Coroutine）来实现 Async/await。协程是一种用户态线程，可以在单线程中实现并发。V8 引擎在编译 JavaScript 代码时会将 Async/await 转化为 Generator 函数，并使用协程来执行这些 Generator 函数。

在 V8 引擎中，每个协程都有一个栈和一个上下文。当执行到 await 关键字时，V8 引擎会将当前协程挂起，并执行下一个协程。当下一个协程执行完成后，V8 引擎会恢复之前挂起的协程，并将 await 后面的表达式结果作为返回值返回给当前协程。

通过使用协程来实现 Async/await，V8 引擎可以在单线程中实现并发，提高代码的执行效率。

## 20-垃圾回收（一）：V8的两个垃圾回收器是如何工作的

### 垃圾回收机制

JavaScript 是一门自动垃圾回收的语言，也就是说，开发者不需要手动回收垃圾数据，而是由 V8 引擎的垃圾回收器来完成。在 JavaScript 中，垃圾数据是指一些不再被程序引用的数据，这些数据会占用内存空间，影响程序的性能。因此，垃圾回收机制是非常重要的。

### V8 引擎中的两个垃圾回收器

为了更高效地回收垃圾，V8 引擎引入了两个垃圾回收器，分别针对不同的场景：

### 新生代垃圾回收器（Scavenge）

适用于存活时间较短的对象

实现方式：将内存空间分为两个相等的半区域（From 空间和 To 空间），对象首先被分配到 From 空间中，当 From 空间快要被占满时，将其中存活的对象复制到 To 空间中，然后交换 From 空间和 To 空间的角色，完成一次垃圾回收。

### 老生代垃圾回收器（Mark-Sweep & Mark-Compact）

适用于存活时间较长的对象

实现方式：将内存空间分为两个部分（新生代空间和老生代空间），新生代空间采用 Scavenge 回收算法，老生代空间采用 Mark-Sweep 和 Mark-Compact 两种算法。Mark-Sweep 算法首先标记所有存活的对象，然后清除所有未标记的对象；Mark-Compact 算法则是在 Mark-Sweep 的基础上，将所有存活的对象向一端移动，并清除另一端的所有对象。

### 总结

本文介绍了 JavaScript 中的垃圾回收机制以及 V8 引擎中的两个垃圾回收器。了解这些知识可以帮助开发者更好地理解 JavaScript 在内存管理方面的工作原理，并且可以优化程序性能。

## 21-垃圾回收（二）：V8是如何优化垃圾回收器执行效率的

本文主要介绍了 V8 引擎是如何通过优化垃圾回收器的执行效率来提高 JavaScript 程序的性能。

### 全停顿

由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。这种行为叫做全停顿（Stop-The-World）。全停顿会导致主线程上的其他任务暂停，从而影响程序的性能和用户体验。

### 优化

为了解决全停顿而造成的用户体验问题，V8 团队通过添加并行、并发和增量等垃圾回收技术，来提高垃圾回收器的执行效率。这些技术主要从两个方面来解决垃圾回收效率问题：

将一个完整的垃圾回收任务拆分成多个小任务，消灭单个长的垃圾回收任务。

将标记对象、移动对象等任务转移到后台线程中执行，减少对主线程的占用。

### 并行

并行是指在多个 CPU 上同时执行多个任务。V8 引擎使用了并行标记和并行清理两种技术来提高垃圾回收器的执行效率。

并行标记：将标记对象的任务分配给多个 CPU 执行，从而减少标记阶段的时间。V8 引擎使用了增量标记和并行标记两种技术来实现并行标记。

并行清理：将清理对象的任务分配给多个 CPU 执行，从而减少清理阶段的时间。V8 引擎使用了增量清理和并行清理两种技术来实现并行清理。

### 并发

并发是指在单个 CPU 上交替执行多个任务。V8 引擎使用了增量标记和增量整理两种技术来实现并发垃圾回收。

增量标记：将标记对象的任务分成多个阶段，在每个阶段之间执行 JavaScript 代码。这样可以让垃圾回收过程与 JavaScript 代码交替执行，减少全停顿的时间。

增量整理：将整理对象的任务分成多个阶段，在每个阶段之间执行 JavaScript 代码。这样可以让垃圾回收过程与 JavaScript 代码交替执行，减少全停顿的时间。

### 增量

增量是指将一个完整的垃圾回收任务分成多个小任务，在每个小任务之间执行 JavaScript 代码。这样可以让垃圾回收过程与 JavaScript 代码交替执行，减少全停顿的时间。V8 引擎使用了增量标记、增量整理和增量清理三种技术来实现增量垃圾回收。

### 总结

V8 引擎通过添加并行、并发和增量等垃圾回收技术，来提高垃圾回收器的执行效率，从而提高 JavaScript 程序的性能。

## 22-几种常见内存问题的解决策略

本文主要讲解了 Node 中的 readFile API 工作机制和 JavaScript 中的几种常见的内存问题。作者通过分析 Node 中的消息循环系统和 JavaScript 中的内存问题出现的原因和解决方法，为读者提供了一些实用的解决方案。

### Node 中的 readFile API 工作机制

在 Node 中，事件循环是由 libuv 提供的，它会从消息队列中取出事件，并在主线程上执行事件。对于一些主线程上不适合处理的事件，比如消耗时间过久的网络资源下载、文件读写、设备访问等，Node 会提供很多线程来处理这些事件，我们把这些线程称为线程池。

在 Node 中，读写文件是一个非常耗时的工作，因此主线程会将回调函数和读文件的操作一道发送给文件读写线程，并让实际的读写操作运行在读写线程中。当在 Node 的主线程上执行 readFile 的时候，主线程会将 readFile 的文件名称和回调函数一道发送给文件读写线程，并让实际的读写操作运行在读写线程中。

### JavaScript 中的几种常见内存问题

JavaScript 中的几种常见内存问题包括内存泄漏、过度使用内存和内存溢出等。这些问题的出现通常是由于程序中存在一些不合理的代码或者设计不当所导致的。

### 内存泄漏

内存泄漏通常是由于程序中存在一些不合理的代码所导致的。比如，在 JavaScript 中，匿名函数可能会导致内存泄漏。解决内存泄漏的方法包括手动释放内存、使用垃圾回收器等。

### 过度使用内存

过度使用内存通常是由于程序中存在一些不合理的代码或者设计不当所导致的。比如，在 JavaScript 中，过度使用闭包可能会导致过度使用内存。解决过度使用内存的方法包括优化代码、减少变量声明、避免使用全局变量等。

### 内存溢出

内存溢出通常是由于程序中存在一些不合理的代码或者设计不当所导致的。比如，在 JavaScript 中，递归调用可能会导致内存溢出。解决内存溢出的方法包括优化代码、使用尾递归等。

### 总结

本文通过分析 Node 中的 readFile API 工作机制和 JavaScript 中的几种常见内存问题，为读者提供了一些实用的解决方案。读者可以通过手动释放内存、使用垃圾回收器、优化代码、减少变量声明、避免使用全局变量等方法来解决这些问题。

## 23-前端学习踩坑史


其实作者（李兵）早些年主要是做C/C++开发的，到了2009年，接触到了浏览器研发，这个时候作者（李兵）对前端并不是太熟悉，但是在开发浏览器的过程中，需要了解大量的前端知识。作者（李兵）当时的学习策略是，只有当遇到了与前端有关的问题时，才会去学习相应的知识来解决。这样做本意是想要节省时间，结果却反而让作者（李兵）花费了更多不必要的时间。

比如在开发双核浏览器的 Cookie 共享的过程中，作者（李兵）发现有一个例外，那就是设置了 HttpOnly 属性的 Cookie 是无法被共享的。

为了解决这个问题，作者（李兵）就去查 HttpOnly 相关概念，发现这和 Web 安全体系有关系，然后作者（李兵）就去补安全相关的知识。之后作者（李兵）又发现，浏览器多进程架构和安全系统息息相关，也就是说，这些知识是环环相扣的。

因为作者（李兵）当时对前端并没有做整体的了解，所以对浏览器中涉及到的安全相关的设计也没有过多关注。每次遇到一些和前端相关的细节问题时，作者（李兵）都需要花费很多时间去补充相关知识，然后再去解决问题，这种方式白白地浪费了作者（李兵）非常多的时间。更加遗憾的是，作者（李兵）之前积累的很多前端知识，都是这么缝缝补补学习过来的。

所以，当你要开发一个新项目或者学习一门手艺之前，应该将其所涉及到的知识做一个全方位的了解。作者（李兵）就觉得发明“技术栈”这个词的人是一个天才，“技术栈”非常形象地表达了学习一门手艺所需要的是哪些知识，以及应该按照什么顺序来学。

比如学习前端这门手艺，栈底到栈顶依次是浏览器架构、Web 网络、事件循环机制、JavaScript 核心、V8 的内存管理、浏览器的渲染流程、Web 安全、CSS、React、Vue、Node、构建工具链等，作者（李兵）们可以从栈底往栈顶一步步循序渐进地学习。

学习技术栈的每一层都不难，难的是当你抛开底层栈的内容去理解上层栈的内容，那么就有可能陷入知识点的盲区。

其实，作者（李兵）们在学习一门手艺的时候，即便没有完善的技术栈资料，只要肯花更多的时间，也可以克服困难。甚至作者（李兵）们的学习过程可以像一个无头苍蝇，横冲直撞，某一天也会突然顿悟整个知识体系 ，俗话说，在一个领域耕耘十年，必定能成为该领域的专家。

但是，三年可以搞定的事，为什么非要花上十年呢？

系统性学习一门技术，花费的时间也是最短的，也可以说是性价比最高的，因为系统性地、循序渐进地学习，那么学习到每个知识点时，其实并没有其他的知识盲区，这样学习起来是最轻松、简单的。

虽然技术栈的概念已经提出来很久了，但是作者（李兵）发现大家对技术栈的理解却不同。比如作者（李兵）们在招聘前端工程师时，经常会看到有人在简历上提到自己的技术栈包含了 Vue、React、Node 等这些偏应用的知识，在作者（李兵）看来，这并不是技术栈，这只不过是栈顶函数的上下文而已，而对于那些在技术栈底层上下文相关的知识，在简历中却很少有提及。所谓技术栈，应该是在某一领域，从底层的基础知识到上层的应用技术有一个完整体系。

那么当作者（李兵）们进入一个领域时，应该如何建立适合自己的技术栈呢？

如果你进入的是一个成熟的领域，那么一般都有比较完整的技术栈的资料，作者（李兵）们需要花些时间分析资料，系统性地了解这一领域知识的宏观架构、它的过往历史、它的优缺点，然后结合现有资料和作者（李兵）们自身的特点来建立作者（李兵）们自己的技术栈。如果你所在的领域还在高速发展中，并没有人总结出完整的技术栈，那么为了更好地理解技术的发展脉络，作者（李兵）们需要花更多一些的时间去整理出该领域的技术栈。

所以后面作者（李兵）就吸取了经验，比如作者（李兵）学习神经网络的过程中，就采取了先构建技术栈的方式，先系统性复习了微积分、概率论、线性代数，然后结合实际项目完成了数据清洗、构建模型、模型训练，最后到实际应用。整个过程作者（李兵）只花了半年时间，最后作者（李兵）对神经网络也有了非常深的认知，现在作者（李兵）们正在打算将神经网络运用到作者（李兵）们的新项目中。

采用了同样的的方法，作者（李兵）在学习区块链和数字货币时，整个过程也是非常轻松的，先分析区块链要解决什么问题，然后整理技术栈，再通过技术栈来一步步学习，不到两周，作者（李兵）基本就把整个数字货币的来龙去脉分析的非常清楚了。


