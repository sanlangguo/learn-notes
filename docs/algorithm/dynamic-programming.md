## 动态规划

动态规划（Dynamic Programming，简称 DP）是一种用于解决**最优化问题**的算法策略。它通过将原问题分解为一系列**相互依赖的子问题**，并**递归地求解**这些子问题，最终得到原问题的最优解。

### 动态规划的适用条件

动态规划算法适用于满足以下两个条件的问题：

1. **子问题重叠:** 原问题可以分解为多个子问题，并且这些子问题之间存在重叠。这意味着同一个子问题可能被多次计算。
2. **最优子结构:** 原问题的最优解包含其子问题的最优解。

### 动态规划的基本思想

动态规划的基本思想是**利用子问题的重叠性质，避免重复计算**。具体来说，动态规划算法会将每个子问题的解**存入表格**中，当再次需要计算同一个子问题时，可以直接从表格中查询结果，从而提高效率。

### 动态规划的两种求解方法

动态规划算法通常有两种求解方法：

1. **自顶向下:** 从原问题出发，递归地求解子问题。在求解子问题时，如果遇到已经计算过的子问题，则直接从表格中查询结果。
2. **自底向上:** 从最简单的子问题开始，逐层递推求解更复杂的子问题，最终得到原问题的解。

### 动态规划的应用

动态规划算法在计算机科学中有着广泛的应用，常见于以下领域：

- **算法设计:** 例如，最长公共子序列、背包问题、0-1 背包问题、最短路径问题、旅行商问题等。
- **机器学习:** 例如，隐马尔可夫模型、条件随机场、最大熵模型等。
- **图像处理:** 例如，图像分割、边缘检测、图像压缩等。
- **金融工程:** 例如，股票期权定价、风险管理等。

### 总结

动态规划是一种强大的算法策略，可以有效地解决许多最优化问题。学习动态规划对于提高算法设计能力和解决实际问题的能力都很有帮助。

**以下是一些学习动态规划的建议:**

- 从简单的例子开始，逐步理解动态规划的基本思想和方法。
- 练习一些经典的动态规划问题，巩固所学知识。
- 尝试将动态规划应用到实际问题中，提高解决问题的能力。



**来自 Goole Gemini** 回答



### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

**简单**

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

```json
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```



**解题思路：**

- **动态规划 (DP)**：将问题分解成子问题，并保存子问题的解决方案，避免重复计算。
- **子问题定义:** 到达第 `i` 阶的不同方法数
- 子问题求解:
  - 到达第 `i` 阶的方法数等于到达第 `i - 1` 阶的方法数加上到达第 `i - 2` 阶的方法数
  - 状态转移方程：`arr[i] = arr[i - 1] + arr[i - 2]`
- 代码实现:
  - 创建一个数组 `arr`，长度为 `n + 1`，并用 `1` 填充
  - 初始化 `arr[0]` 和 `arr[2]`
  - 从第 3 阶开始，逐个计算到达该阶的不同方法数
  - 返回到达第 `n` 阶的不同方法数

```js
/**
 * 爬楼梯问题
 * 
 * @param {number} n 楼梯的阶数
 * @return {number} 到达顶层的不同方法数
 */
var climbStairs = function(n) {
  // 创建一个数组 `arr`，长度为 `n + 1`，并用 `1` 填充
  const arr = Array(n + 1).fill(1);

  // 初始化 `arr[0]` 和 `arr[2]`
  arr[0] = 0;
  arr[2] = 2;

  // 从第 3 阶开始，逐个计算到达该阶的不同方法数
  for (let i = 3; i <= n; i++) {
    // 到达第 `i` 阶的方法数等于到达第 `i - 1` 阶的方法数加上到达第 `i - 2` 阶的方法数
    arr[i] = arr[i - 1] + arr[i - 2];
  }

  // 返回到达第 `n` 阶的不同方法数
  return arr[n];
};

```





### [118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

[思路](https://leetcode.cn/problems/pascals-triangle/description/?envType=study-plan-v2&envId=top-100-liked#)

**简单**

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

 

**示例 1:**

```
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

**解题思路:**

- 使用递推公式逐个计算杨辉三角的每一行。
- 从第 0 行开始，第 0 行只有一个元素，值为 1。
- 从第 1 行开始，每行的第一个元素和最后一个元素都为 1。
- 对于每行的其他元素，其值等于上一行的相邻两个元素的和。

```js
/**
 * 生成杨辉三角，使用滚动数组优化空间复杂度
 *
 * @param {number} numRows 杨辉三角的行数
 * @return {number[][]} 杨辉三角
 */
var generate = function (numRows) {
  // 创建结果数组
  const res = [[1]];

  // 从第 1 行开始，逐个生成杨辉三角的每一行
  for (let i = 1; i < numRows; i++) {
    // 创建一行数据，并用 `1` 填充
    const row = [1];

    // 使用前两行的杨辉三角数据进行计算
    const prev = res[i - 1];
    for (let j = 1; j < i; j++) {
      // 每个元素的值等于上一行的相邻两个元素的和
      row[j] = prev[j - 1] + prev[j];
    }

    // 将生成的这一行添加到结果数组中
    row.push(1);
    res.push(row);
  }

  // 返回结果数组
  return res;
};


```



### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

**中等**

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

**示例 1：**

```json
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```



**思路：**

- 动态规划 (DP)

**步骤：**

1. 定义状态：`dp[i]` 表示偷窃到第 `i` 间房屋的最大金额。
2. 状态转移方程：
   - `dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])`
   - 含义：偷窃到第 i 间房屋的最大金额等于两种情况中的较大值：
     - 不偷窃第 `i` 间房屋，则最大金额为之前第 `i - 1` 间房屋的最大金额 (`dp[i - 1]`)
     - 偷窃第 `i` 间房屋，则最大金额为之前第 `i - 2` 间房屋的最大金额 (`dp[i - 2]`) 加上第 `i` 间房屋的金额 (`nums[i]`)
3. 初始化：
   - `dp[0] = nums[0]`
   - `dp[1] = max(nums[1], nums[0])`
4. 计算：
   - 从第 3 间房屋开始，逐个计算 `dp[i]`
5. 返回结果：
   - 返回 `dp[n - 1]`，表示偷窃到最后间房屋的最大金额

```js

/**
 * 窃取房屋中的最大金额（不可窃取相邻的房屋），使用滚动数组优化空间复杂度
 *
 * @param {number[]} nums 每间房屋中的金额
 * @return {number} 最大利润
 */
var rob = function (nums) {
  // 如果只有一间房屋，则直接返回该房屋的金额
  if (nums.length === 1) return nums[0];

  // 初始化两个变量，分别保存前两间房屋的最大金额
  let prev1 = nums[0];
  let prev2 = Math.max(nums[1], nums[0]);

  // 从第 3 间房屋开始，逐个计算偷窃到该房屋为止的最大金额
  for (let i = 2; i < nums.length; i++) {
    // 偷窃到第 `i` 间房屋的最大金额等于两种情况中的较大值：
    //   1. 不偷窃第 `i` 间房屋，则最大金额为之前第 `i - 1` 间房屋的最大金额 (`prev1`)
    //   2. 偷窃第 `i` 间房屋，则最大金额为之前第 `i - 2` 间房屋的最大金额 (`prev2`) 加上第 `i` 间房屋的金额 (`nums[i]`)
    const temp = Math.max(prev1, prev2 + nums[i]);

    // 更新 `prev1` 和 `prev2` 的值
    prev1 = prev2;
    prev2 = temp;
  }

  // 返回偷窃到最后一间房屋为止的最大金额
  return prev2;
};

```





### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

**中等**

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

 

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```



**解题思路**

- 状态：`dp[i]` 表示组成数字 `i` 所需的最小完美平方数个数。
- 状态转移方程：
  - `dp[i] = min(dp[i - j^2] + 1)`，其中 `j` 为所有可能的平方数，且 `j^2 <= i`。
  - 含义：对于数字i，我们可以尝试从 1 到i的所有平方数开始，
    - 如果 `i` 减去某个平方数 `j^2` 仍然是非负数，则我们可以使用 `dp[i - j^2]` 来表示组成 `i - j^2` 所需的最小完美平方数个数。
    - 然后，再加上 1 表示使用了一个平方数 `j^2`，得到组成 `i` 所需的最小完美平方数个数。
- 初始化：
  - `dp[0] = 0`，因为组成 0 不需要任何平方数。
- 计算：
  - 从 1 到 n 遍历每个数字i，对于每个数字i从 1 到 `i` 的所有平方数 `j^2` 开始，
    - 计算 `dp[i - j^2] + 1` 的值，
    - 更新 `dp[i]` 的值为所有可能的 `dp[i - j^2] + 1` 的最小值。
- 返回结果：
  - 返回 `dp[n]`，即组成目标数字 `n` 所需的最小完美平方数个数。



```js
/**
 * 计算完美平方数的最小个数
 *
 * @param {number} n 目标数字
 * @return {number} 最小平方数个数
 */
var numSquares = function (n) {
  // 创建一个 dp 数组，存储从 0 到 n 的每个数字所需的最小平方数个数
  const dp = Array(n + 1).fill(n + 1);

  // 初始化 dp[0]
  dp[0] = 0;

  // 从 1 到 n 遍历每个数字
  for (let i = 1; i * i <= n; i++) {
    // 从 1 到 n 遍历每个数字
    for (let j = 1; j <= n; j++) {
      // 如果目标数字大于等于当前平方数
      if (j >= i * i) {
        // 更新 dp[j] 的值，取之前的值和使用当前平方数凑成目标数字的最小值
        dp[j] = Math.min(dp[j], dp[j - i * i] + 1);
      }
    }
  }

  // 返回 dp[n]，即目标数字所需的最小平方数个数
  return dp[n];
};

```



### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

**中等**

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

 

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

 **解题思路**

- 状态：`dp[i]` 表示组成金额 `i` 所需的最小硬币数。
- 状态转移方程：
  - `dp[i] = min(dp[i - c] + 1)`，其中 `c` 为所有可能的硬币面额。
  - 含义：对于金额i，我们可以尝试从所有可用的硬币面额开始，
    - 如果 `i` 减去某个硬币面额 `c` 仍然是非负数，则我们可以使用 `dp[i - c]` 来表示组成 `i - c` 所需的最小硬币数。
    - 然后，再加上 1 表示使用了一个硬币，得到组成 `i` 所需的最小硬币数。
- 初始化：
  - `dp[0] = 0`，因为组成 0 不需要任何硬币。
- 计算：
  - 从 1 到 `amount` 遍历每个金额 `i`，
  - 对于每个金额 `i`，遍历所有可用的硬币面额 `c`，
  - 计算 `dp[i - c] + 1` 的值，
  - 更新 `dp[i]` 的值为所有可能的 `dp[i - c] + 1` 的最小值。
- 返回结果：
  - 返回 `dp[amount]`，即组成目标金额 `amount` 所需的最小硬币数。
  - 如果 `dp[amount]` 等于 `amount + 1`，则说明目标金额无法凑成，返回 -1。



```js
/**
 * 计算组成目标金额所需的最少硬币数
 *
 * @param {number[]} coins 可用的硬币面额数组
 * @param {number} amount 目标金额
 * @return {number} 最少硬币数
 */
var coinChange = function (coins, amount) {
  // 创建一个 dp 数组，存储从 0 到 amount 的每个金额所需的最小硬币数
  const dp = Array(amount + 1).fill(amount + 1);

  // 初始化 dp[0]
  dp[0] = 0;

  // 遍历所有硬币面额
  for (let i = 0; i < coins.length; i++) {
    // 从当前硬币面额开始，遍历所有可能的金额
    for (let j = coins[i]; j <= amount; j++) {
      // 更新 dp[j] 的值，取之前的值和使用当前硬币凑成目标金额的最小值
      dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
    }
  }

  // 如果目标金额无法凑成，则返回 -1
  return dp[amount] === amount + 1 ? -1 : dp[amount];
};

```

