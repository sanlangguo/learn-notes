<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-rc.0">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/img/logo.jpg"><title>三郎过</title><meta name="description" content="">
    <link rel="preload" href="/learn-notes/assets/style-yOPNiTGp.css" as="style"><link rel="stylesheet" href="/learn-notes/assets/style-yOPNiTGp.css">
    <link rel="modulepreload" href="/learn-notes/assets/app-B-42ZPY7.js"><link rel="modulepreload" href="/learn-notes/assets/binary-tree.html-ByxgpjVy.js"><link rel="modulepreload" href="/learn-notes/assets/binary-tree.html-Bq8Klt4V.js">
    <link rel="prefetch" href="/learn-notes/assets/index.html-CSTD-NQC.js" as="script"><link rel="prefetch" href="/learn-notes/assets/binary-search.html-B-xySPZC.js" as="script"><link rel="prefetch" href="/learn-notes/assets/dynamic-programming.html-DlJcJFP9.js" as="script"><link rel="prefetch" href="/learn-notes/assets/linked-list.html-G3Kcm1WZ.js" as="script"><link rel="prefetch" href="/learn-notes/assets/ios.html-86a5Eh8y.js" as="script"><link rel="prefetch" href="/learn-notes/assets/lerna.html-CF6wPHlA.js" as="script"><link rel="prefetch" href="/learn-notes/assets/qiankunShadow.html-C2Qkua74.js" as="script"><link rel="prefetch" href="/learn-notes/assets/vite-build.html-BE22va4b.js" as="script"><link rel="prefetch" href="/learn-notes/assets/01.html-9oVSisH-.js" as="script"><link rel="prefetch" href="/learn-notes/assets/02.html-TX-XKBwX.js" as="script"><link rel="prefetch" href="/learn-notes/assets/03.html-dC2_Zttb.js" as="script"><link rel="prefetch" href="/learn-notes/assets/04.html-C6QrXIg7.js" as="script"><link rel="prefetch" href="/learn-notes/assets/05.html-BWKPGKvI.js" as="script"><link rel="prefetch" href="/learn-notes/assets/06.html-BY4aMPo9.js" as="script"><link rel="prefetch" href="/learn-notes/assets/07.html-C6mCPbLW.js" as="script"><link rel="prefetch" href="/learn-notes/assets/08.html-Jv1e0huT.js" as="script"><link rel="prefetch" href="/learn-notes/assets/09.html-uJxvGbe9.js" as="script"><link rel="prefetch" href="/learn-notes/assets/10.html-CmEt5Nm5.js" as="script"><link rel="prefetch" href="/learn-notes/assets/11.html-DIINp3T9.js" as="script"><link rel="prefetch" href="/learn-notes/assets/12.html-wuYHD_Ix.js" as="script"><link rel="prefetch" href="/learn-notes/assets/13.html-CyIQbEHY.js" as="script"><link rel="prefetch" href="/learn-notes/assets/14.html-BLUcc7JV.js" as="script"><link rel="prefetch" href="/learn-notes/assets/15.html-DzVgI1Wk.js" as="script"><link rel="prefetch" href="/learn-notes/assets/16.html-IAG3a0o2.js" as="script"><link rel="prefetch" href="/learn-notes/assets/17.html-C6SFS_7c.js" as="script"><link rel="prefetch" href="/learn-notes/assets/18.html-Djb4E6ZM.js" as="script"><link rel="prefetch" href="/learn-notes/assets/19.html-BIgtTfSV.js" as="script"><link rel="prefetch" href="/learn-notes/assets/20.html-Cgb_2qDl.js" as="script"><link rel="prefetch" href="/learn-notes/assets/21.html-Cki8xouD.js" as="script"><link rel="prefetch" href="/learn-notes/assets/22.html-P90rYcwA.js" as="script"><link rel="prefetch" href="/learn-notes/assets/23.html-BVo8e0nu.js" as="script"><link rel="prefetch" href="/learn-notes/assets/24.html-BHpKR41A.js" as="script"><link rel="prefetch" href="/learn-notes/assets/25.html-BlDXMQXU.js" as="script"><link rel="prefetch" href="/learn-notes/assets/26.html-DAovXR1v.js" as="script"><link rel="prefetch" href="/learn-notes/assets/27.html-BvJ6TCW0.js" as="script"><link rel="prefetch" href="/learn-notes/assets/28.html-VFA_A0Wz.js" as="script"><link rel="prefetch" href="/learn-notes/assets/29.html-7lKsL0us.js" as="script"><link rel="prefetch" href="/learn-notes/assets/30.html-Dg2xjLLT.js" as="script"><link rel="prefetch" href="/learn-notes/assets/31.html-CdWOpf8d.js" as="script"><link rel="prefetch" href="/learn-notes/assets/32.html-DszfHuaz.js" as="script"><link rel="prefetch" href="/learn-notes/assets/33.html-BzvxieEy.js" as="script"><link rel="prefetch" href="/learn-notes/assets/34.html-Bi5uIYPm.js" as="script"><link rel="prefetch" href="/learn-notes/assets/35.html-Bmyp4Pks.js" as="script"><link rel="prefetch" href="/learn-notes/assets/36.html-JlopPL8T.js" as="script"><link rel="prefetch" href="/learn-notes/assets/list.html-DTRF6ONM.js" as="script"><link rel="prefetch" href="/learn-notes/assets/wechat.html-B2diHmTt.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-CMASpgqb.js" as="script"><link rel="prefetch" href="/learn-notes/assets/list.html-qSNQle6r.js" as="script"><link rel="prefetch" href="/learn-notes/assets/WebGL_01.html-CyEo-kNa.js" as="script"><link rel="prefetch" href="/learn-notes/assets/base-ts.html-ClALpFFb.js" as="script"><link rel="prefetch" href="/learn-notes/assets/js.html-CNppsnKk.js" as="script"><link rel="prefetch" href="/learn-notes/assets/h5-jump-app.html-9bVRScjf.js" as="script"><link rel="prefetch" href="/learn-notes/assets/list.html-gXpHdXh0.js" as="script"><link rel="prefetch" href="/learn-notes/assets/学习node知识框架.html-CeYCHE4q.js" as="script"><link rel="prefetch" href="/learn-notes/assets/模块化介绍.html-DvMD5frz.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-Y-Eh76sB.js" as="script"><link rel="prefetch" href="/learn-notes/assets/common-problem.html-CorfAKa6.js" as="script"><link rel="prefetch" href="/learn-notes/assets/contrast.html-BFsUwF40.js" as="script"><link rel="prefetch" href="/learn-notes/assets/tl-list.html-J9MsOLco.js" as="script"><link rel="prefetch" href="/learn-notes/assets/user-tools.html-DA9BLri9.js" as="script"><link rel="prefetch" href="/learn-notes/assets/AppendArgument.html-BIJMu71D.js" as="script"><link rel="prefetch" href="/learn-notes/assets/Combination.html-Dd06Ff_e.js" as="script"><link rel="prefetch" href="/learn-notes/assets/Concat.html-MM9xgk63.js" as="script"><link rel="prefetch" href="/learn-notes/assets/Exclude.html-Ye8tt8Nt.js" as="script"><link rel="prefetch" href="/learn-notes/assets/Omit.html-D6gU3k3m.js" as="script"><link rel="prefetch" href="/learn-notes/assets/list.html-smWBnV3j.js" as="script"><link rel="prefetch" href="/learn-notes/assets/pick.html-DZ87od9k.js" as="script"><link rel="prefetch" href="/learn-notes/assets/type.html-DD3dVjjz.js" as="script"><link rel="prefetch" href="/learn-notes/assets/01.html-UwEZ6Kx-.js" as="script"><link rel="prefetch" href="/learn-notes/assets/02.html-hlYuAiIK.js" as="script"><link rel="prefetch" href="/learn-notes/assets/03.html-CVcUJn6C.js" as="script"><link rel="prefetch" href="/learn-notes/assets/04.html-2_zl7JtB.js" as="script"><link rel="prefetch" href="/learn-notes/assets/05.html-BdGATXUs.js" as="script"><link rel="prefetch" href="/learn-notes/assets/06.html-xX_dzY8v.js" as="script"><link rel="prefetch" href="/learn-notes/assets/07.html-DTZwg8Hu.js" as="script"><link rel="prefetch" href="/learn-notes/assets/08.html-B2l_DwB6.js" as="script"><link rel="prefetch" href="/learn-notes/assets/09.html-BDDG3qAY.js" as="script"><link rel="prefetch" href="/learn-notes/assets/10.html-CyPh615q.js" as="script"><link rel="prefetch" href="/learn-notes/assets/11.html-4IaZ1ax0.js" as="script"><link rel="prefetch" href="/learn-notes/assets/12.html-Dp1Lx70M.js" as="script"><link rel="prefetch" href="/learn-notes/assets/13.html-DY5e7Vjc.js" as="script"><link rel="prefetch" href="/learn-notes/assets/14.html-b0D6Wamn.js" as="script"><link rel="prefetch" href="/learn-notes/assets/15.html-CI0S8V8s.js" as="script"><link rel="prefetch" href="/learn-notes/assets/16.html-knd-QUpB.js" as="script"><link rel="prefetch" href="/learn-notes/assets/17.html-Bu0HwOFC.js" as="script"><link rel="prefetch" href="/learn-notes/assets/18.html-CQDewHhx.js" as="script"><link rel="prefetch" href="/learn-notes/assets/19.html-Bbal-ZC1.js" as="script"><link rel="prefetch" href="/learn-notes/assets/20.html-BXD3_WNT.js" as="script"><link rel="prefetch" href="/learn-notes/assets/21.html-C4OqUq8K.js" as="script"><link rel="prefetch" href="/learn-notes/assets/22.html-DgzjnHAB.js" as="script"><link rel="prefetch" href="/learn-notes/assets/23.html-Ddr3AK5d.js" as="script"><link rel="prefetch" href="/learn-notes/assets/list.html-L7znxJDY.js" as="script"><link rel="prefetch" href="/learn-notes/assets/devise-realization.html-BrMR8B7A.js" as="script"><link rel="prefetch" href="/learn-notes/assets/v2-v3.html-mIuPtRlK.js" as="script"><link rel="prefetch" href="/learn-notes/assets/vue.html-732Sq1gx.js" as="script"><link rel="prefetch" href="/learn-notes/assets/如何系统学习一个新知识.html-DBsek05C.js" as="script"><link rel="prefetch" href="/learn-notes/assets/404.html-CnfmQthm.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-DYbabKBl.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-DX9_DsEn.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-DTybGN9A.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-HxdYulsp.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-BPri-pt-.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-npZhPqdQ.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-Cuwy-8dy.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-CANrR57a.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-CZjCAcIA.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-wMUczMxE.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-BdyNPbrh.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-JFB-srHR.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-PlqzuxB9.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-B22HzouV.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-DwipLvPZ.js" as="script"><link rel="prefetch" href="/learn-notes/assets/binary-search.html-DuWIsy5x.js" as="script"><link rel="prefetch" href="/learn-notes/assets/dynamic-programming.html-B70A_fN1.js" as="script"><link rel="prefetch" href="/learn-notes/assets/linked-list.html-D3jzXQnK.js" as="script"><link rel="prefetch" href="/learn-notes/assets/ios.html-BBOkjc7u.js" as="script"><link rel="prefetch" href="/learn-notes/assets/lerna.html-WS6CMXuP.js" as="script"><link rel="prefetch" href="/learn-notes/assets/qiankunShadow.html-C8uhwWaj.js" as="script"><link rel="prefetch" href="/learn-notes/assets/vite-build.html-CuK7TkLn.js" as="script"><link rel="prefetch" href="/learn-notes/assets/01.html-EX8JKxk8.js" as="script"><link rel="prefetch" href="/learn-notes/assets/02.html-CWkYH5c_.js" as="script"><link rel="prefetch" href="/learn-notes/assets/03.html-BzYfDSw5.js" as="script"><link rel="prefetch" href="/learn-notes/assets/04.html-DydVaoeV.js" as="script"><link rel="prefetch" href="/learn-notes/assets/05.html-BvuyR8XX.js" as="script"><link rel="prefetch" href="/learn-notes/assets/06.html-5XXqd1Ur.js" as="script"><link rel="prefetch" href="/learn-notes/assets/07.html-CexDuF50.js" as="script"><link rel="prefetch" href="/learn-notes/assets/08.html-CDF2g7_7.js" as="script"><link rel="prefetch" href="/learn-notes/assets/09.html-DAYrdQoE.js" as="script"><link rel="prefetch" href="/learn-notes/assets/10.html-CRSoEKro.js" as="script"><link rel="prefetch" href="/learn-notes/assets/11.html-rNrWXVv7.js" as="script"><link rel="prefetch" href="/learn-notes/assets/12.html-BS2bfZmn.js" as="script"><link rel="prefetch" href="/learn-notes/assets/13.html-0VfOo5h1.js" as="script"><link rel="prefetch" href="/learn-notes/assets/14.html-tp7v6TEV.js" as="script"><link rel="prefetch" href="/learn-notes/assets/15.html-Tqos0hGt.js" as="script"><link rel="prefetch" href="/learn-notes/assets/16.html-d9biF9F4.js" as="script"><link rel="prefetch" href="/learn-notes/assets/17.html-CTGW4qTi.js" as="script"><link rel="prefetch" href="/learn-notes/assets/18.html-CZY0Brc-.js" as="script"><link rel="prefetch" href="/learn-notes/assets/19.html-Bu4ZSNQi.js" as="script"><link rel="prefetch" href="/learn-notes/assets/20.html-Bi57xre9.js" as="script"><link rel="prefetch" href="/learn-notes/assets/21.html-yVKqjZvG.js" as="script"><link rel="prefetch" href="/learn-notes/assets/22.html-DYSH4IjF.js" as="script"><link rel="prefetch" href="/learn-notes/assets/23.html-CZLLdxdN.js" as="script"><link rel="prefetch" href="/learn-notes/assets/24.html-DdRqcnyZ.js" as="script"><link rel="prefetch" href="/learn-notes/assets/25.html-C6m1v_VQ.js" as="script"><link rel="prefetch" href="/learn-notes/assets/26.html-DnAttyES.js" as="script"><link rel="prefetch" href="/learn-notes/assets/27.html-Bs_kPsvw.js" as="script"><link rel="prefetch" href="/learn-notes/assets/28.html-BRYCVvTu.js" as="script"><link rel="prefetch" href="/learn-notes/assets/29.html-siVRB5Dl.js" as="script"><link rel="prefetch" href="/learn-notes/assets/30.html-BYiesiZ5.js" as="script"><link rel="prefetch" href="/learn-notes/assets/31.html-CepXafGO.js" as="script"><link rel="prefetch" href="/learn-notes/assets/32.html-DYZTKwck.js" as="script"><link rel="prefetch" href="/learn-notes/assets/33.html-Df6bCaRh.js" as="script"><link rel="prefetch" href="/learn-notes/assets/34.html-JRoLRYHM.js" as="script"><link rel="prefetch" href="/learn-notes/assets/35.html-D3vG-FOq.js" as="script"><link rel="prefetch" href="/learn-notes/assets/36.html-CbmTlGav.js" as="script"><link rel="prefetch" href="/learn-notes/assets/list.html-BwZy74Ki.js" as="script"><link rel="prefetch" href="/learn-notes/assets/wechat.html-D_uNdBQb.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-BHru_ezx.js" as="script"><link rel="prefetch" href="/learn-notes/assets/list.html-DhNZ_qwT.js" as="script"><link rel="prefetch" href="/learn-notes/assets/WebGL_01.html-B5nFopzx.js" as="script"><link rel="prefetch" href="/learn-notes/assets/base-ts.html-CWG9oNFg.js" as="script"><link rel="prefetch" href="/learn-notes/assets/js.html-CeXH-9os.js" as="script"><link rel="prefetch" href="/learn-notes/assets/h5-jump-app.html-D-LJTgrC.js" as="script"><link rel="prefetch" href="/learn-notes/assets/list.html-D5yb2FbY.js" as="script"><link rel="prefetch" href="/learn-notes/assets/学习node知识框架.html-By1B7lZi.js" as="script"><link rel="prefetch" href="/learn-notes/assets/模块化介绍.html-Ddgr1dNi.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-BJmMEplo.js" as="script"><link rel="prefetch" href="/learn-notes/assets/common-problem.html-Dj15wbnJ.js" as="script"><link rel="prefetch" href="/learn-notes/assets/contrast.html-MgVANBxW.js" as="script"><link rel="prefetch" href="/learn-notes/assets/tl-list.html-DHhqGZqh.js" as="script"><link rel="prefetch" href="/learn-notes/assets/user-tools.html-BM1bufE6.js" as="script"><link rel="prefetch" href="/learn-notes/assets/AppendArgument.html-BqYMPncn.js" as="script"><link rel="prefetch" href="/learn-notes/assets/Combination.html-CDTgte16.js" as="script"><link rel="prefetch" href="/learn-notes/assets/Concat.html-BPae87up.js" as="script"><link rel="prefetch" href="/learn-notes/assets/Exclude.html-Wd10pqdr.js" as="script"><link rel="prefetch" href="/learn-notes/assets/Omit.html-Cjojd8Ro.js" as="script"><link rel="prefetch" href="/learn-notes/assets/list.html-D-g-A3q3.js" as="script"><link rel="prefetch" href="/learn-notes/assets/pick.html-DMJguMjJ.js" as="script"><link rel="prefetch" href="/learn-notes/assets/type.html-KB_enWDa.js" as="script"><link rel="prefetch" href="/learn-notes/assets/01.html-BNZ3Ym2k.js" as="script"><link rel="prefetch" href="/learn-notes/assets/02.html-CR9YtTUf.js" as="script"><link rel="prefetch" href="/learn-notes/assets/03.html-5vstLybj.js" as="script"><link rel="prefetch" href="/learn-notes/assets/04.html-zEfQ93Eu.js" as="script"><link rel="prefetch" href="/learn-notes/assets/05.html-CjvtQguI.js" as="script"><link rel="prefetch" href="/learn-notes/assets/06.html-Ky3FXdgr.js" as="script"><link rel="prefetch" href="/learn-notes/assets/07.html-Bj3FAIwW.js" as="script"><link rel="prefetch" href="/learn-notes/assets/08.html-CVZXyRsZ.js" as="script"><link rel="prefetch" href="/learn-notes/assets/09.html-Ce9qwFzu.js" as="script"><link rel="prefetch" href="/learn-notes/assets/10.html-Ce5svY02.js" as="script"><link rel="prefetch" href="/learn-notes/assets/11.html-DC9L8yac.js" as="script"><link rel="prefetch" href="/learn-notes/assets/12.html-BSHg8hmf.js" as="script"><link rel="prefetch" href="/learn-notes/assets/13.html-DsKf53EP.js" as="script"><link rel="prefetch" href="/learn-notes/assets/14.html-D6PpNdWQ.js" as="script"><link rel="prefetch" href="/learn-notes/assets/15.html-DEmDoQSN.js" as="script"><link rel="prefetch" href="/learn-notes/assets/16.html-pPk5Y0BV.js" as="script"><link rel="prefetch" href="/learn-notes/assets/17.html-BtGMi9IM.js" as="script"><link rel="prefetch" href="/learn-notes/assets/18.html-CidIsUF_.js" as="script"><link rel="prefetch" href="/learn-notes/assets/19.html-DWE1UFVb.js" as="script"><link rel="prefetch" href="/learn-notes/assets/20.html-Dfv6Y-aS.js" as="script"><link rel="prefetch" href="/learn-notes/assets/21.html-Selcw_XC.js" as="script"><link rel="prefetch" href="/learn-notes/assets/22.html-grKgvESp.js" as="script"><link rel="prefetch" href="/learn-notes/assets/23.html-s9HDqqA2.js" as="script"><link rel="prefetch" href="/learn-notes/assets/list.html-NOHQ3odm.js" as="script"><link rel="prefetch" href="/learn-notes/assets/devise-realization.html-2tTxY4D9.js" as="script"><link rel="prefetch" href="/learn-notes/assets/v2-v3.html-aYd0PFaU.js" as="script"><link rel="prefetch" href="/learn-notes/assets/vue.html-BX3ObkBO.js" as="script"><link rel="prefetch" href="/learn-notes/assets/如何系统学习一个新知识.html-qMXkXMi2.js" as="script"><link rel="prefetch" href="/learn-notes/assets/404.html-COPMSMZI.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-DFMKMXtK.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-DSXPCo3m.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-CwR1oiXg.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-BhRr16h2.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-K8Nqmllm.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-zGtwcR9H.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-D7b9E9kq.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-Cyk4wyBb.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-Zrw3gPKP.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-CIH2AiNt.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-Dk3xEGOn.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-BoARx7zA.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-Dur7paBa.js" as="script"><link rel="prefetch" href="/learn-notes/assets/index.html-Ddg9h258.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/learn-notes/" class=""><img class="logo" src="/learn-notes/img/logo.jpg" alt="三郎过"><span class="site-name can-hide">三郎过</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/learn-notes/nav/list.md" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="算法"><span class="title">算法</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="算法"><span class="title">算法</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/learn-notes/algorithm/linked-list.md" class="" aria-label="链表"><!--[--><!--]--> 链表 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/algorithm/binary-tree.md" class="" aria-label="二叉树"><!--[--><!--]--> 二叉树 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/algorithm/binary-search.md" class="" aria-label="二分查找"><!--[--><!--]--> 二分查找 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="动画"><span class="title">动画</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="动画"><span class="title">动画</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/learn-notes/js/WebGL_01.md" class="" aria-label="初识 WebGL"><!--[--><!--]--> 初识 WebGL <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="JS"><span class="title">JS</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="JS"><span class="title">JS</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/learn-notes/js/js.md" class="" aria-label="js常见问题汇总"><!--[--><!--]--> js常见问题汇总 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/js/base-ts.md" class="" aria-label="TS入门学习记录"><!--[--><!--]--> TS入门学习记录 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/ts/list.md" class="" aria-label="TS 使用指南"><!--[--><!--]--> TS 使用指南 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a href="/learn-notes/http/index.md" class="" aria-label="http"><!--[--><!--]--> http <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="前端框架"><span class="title">前端框架</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="前端框架"><span class="title">前端框架</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/learn-notes/nuxt/index.md" class="" aria-label="nuxt3"><!--[--><!--]--> nuxt3 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/vue/vue.md" class="" aria-label="vue 常见问题汇总"><!--[--><!--]--> vue 常见问题汇总 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/vue/v2-v3.md" class="" aria-label="vue3"><!--[--><!--]--> vue3 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/vue/devise-realization.md" class="" aria-label="vue3设计与实现"><!--[--><!--]--> vue3设计与实现 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/react/contrast.md" class="" aria-label="react系统知识梳理"><!--[--><!--]--> react系统知识梳理 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/react/common-problem.md" class="" aria-label="react常见问题"><!--[--><!--]--> react常见问题 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="前端工程化"><span class="title">前端工程化</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="前端工程化"><span class="title">前端工程化</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/learn-notes/engineering/vite-build.md" class="" aria-label="vue3 vite 打包优化"><!--[--><!--]--> vue3 vite 打包优化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://xxpromise.gitee.io/webpack5-docs/" rel="noopener noreferrer" target="_blank" aria-label="webpack"><!--[--><!--]--> webpack <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/engineering/lerna.md" class="" aria-label="Lerna"><!--[--><!--]--> Lerna <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/engineering/ios.md" class="" aria-label="ios 真机调试"><!--[--><!--]--> ios 真机调试 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/engineering/qiankunShadow.md" class="" aria-label="qiankun隔离方案"><!--[--><!--]--> qiankun隔离方案 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="常用工具"><span class="title">常用工具</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="常用工具"><span class="title">常用工具</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/learn-notes/tools/tl-list.md" class="" aria-label="前端学习常用网站"><!--[--><!--]--> 前端学习常用网站 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/tools/user-tools.md" class="" aria-label="工作中常用工具网站"><!--[--><!--]--> 工作中常用工具网站 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="浏览器"><span class="title">浏览器</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="浏览器"><span class="title">浏览器</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/learn-notes/browser/list.md" class="" aria-label="浏览器原理(极客时间)"><!--[--><!--]--> 浏览器原理(极客时间) <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/v8/list.md" class="" aria-label="V8原理(极客时间)"><!--[--><!--]--> V8原理(极客时间) <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/browser/wechat.md" class="" aria-label="微信公众号经验记录"><!--[--><!--]--> 微信公众号经验记录 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/sanlangguo/learn-notes" rel="noopener noreferrer" target="_blank" aria-label="github"><!--[--><!--]--> github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-color-mode-button" title="toggle color mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/learn-notes/nav/list.md" class="" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="算法"><span class="title">算法</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="算法"><span class="title">算法</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/learn-notes/algorithm/linked-list.md" class="" aria-label="链表"><!--[--><!--]--> 链表 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/algorithm/binary-tree.md" class="" aria-label="二叉树"><!--[--><!--]--> 二叉树 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/algorithm/binary-search.md" class="" aria-label="二分查找"><!--[--><!--]--> 二分查找 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="动画"><span class="title">动画</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="动画"><span class="title">动画</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/learn-notes/js/WebGL_01.md" class="" aria-label="初识 WebGL"><!--[--><!--]--> 初识 WebGL <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="JS"><span class="title">JS</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="JS"><span class="title">JS</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/learn-notes/js/js.md" class="" aria-label="js常见问题汇总"><!--[--><!--]--> js常见问题汇总 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/js/base-ts.md" class="" aria-label="TS入门学习记录"><!--[--><!--]--> TS入门学习记录 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/ts/list.md" class="" aria-label="TS 使用指南"><!--[--><!--]--> TS 使用指南 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a href="/learn-notes/http/index.md" class="" aria-label="http"><!--[--><!--]--> http <!--[--><!--]--></a></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="前端框架"><span class="title">前端框架</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="前端框架"><span class="title">前端框架</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/learn-notes/nuxt/index.md" class="" aria-label="nuxt3"><!--[--><!--]--> nuxt3 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/vue/vue.md" class="" aria-label="vue 常见问题汇总"><!--[--><!--]--> vue 常见问题汇总 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/vue/v2-v3.md" class="" aria-label="vue3"><!--[--><!--]--> vue3 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/vue/devise-realization.md" class="" aria-label="vue3设计与实现"><!--[--><!--]--> vue3设计与实现 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/react/contrast.md" class="" aria-label="react系统知识梳理"><!--[--><!--]--> react系统知识梳理 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/react/common-problem.md" class="" aria-label="react常见问题"><!--[--><!--]--> react常见问题 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="前端工程化"><span class="title">前端工程化</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="前端工程化"><span class="title">前端工程化</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/learn-notes/engineering/vite-build.md" class="" aria-label="vue3 vite 打包优化"><!--[--><!--]--> vue3 vite 打包优化 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a class="external-link" href="https://xxpromise.gitee.io/webpack5-docs/" rel="noopener noreferrer" target="_blank" aria-label="webpack"><!--[--><!--]--> webpack <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/engineering/lerna.md" class="" aria-label="Lerna"><!--[--><!--]--> Lerna <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/engineering/ios.md" class="" aria-label="ios 真机调试"><!--[--><!--]--> ios 真机调试 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/engineering/qiankunShadow.md" class="" aria-label="qiankun隔离方案"><!--[--><!--]--> qiankun隔离方案 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="常用工具"><span class="title">常用工具</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="常用工具"><span class="title">常用工具</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/learn-notes/tools/tl-list.md" class="" aria-label="前端学习常用网站"><!--[--><!--]--> 前端学习常用网站 <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/tools/user-tools.md" class="" aria-label="工作中常用工具网站"><!--[--><!--]--> 工作中常用工具网站 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><div class="navbar-dropdown-wrapper"><button class="navbar-dropdown-title" type="button" aria-label="浏览器"><span class="title">浏览器</span><span class="arrow down"></span></button><button class="navbar-dropdown-title-mobile" type="button" aria-label="浏览器"><span class="title">浏览器</span><span class="right arrow"></span></button><ul style="display:none;" class="navbar-dropdown"><!--[--><li class="navbar-dropdown-item"><a href="/learn-notes/browser/list.md" class="" aria-label="浏览器原理(极客时间)"><!--[--><!--]--> 浏览器原理(极客时间) <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/v8/list.md" class="" aria-label="V8原理(极客时间)"><!--[--><!--]--> V8原理(极客时间) <!--[--><!--]--></a></li><li class="navbar-dropdown-item"><a href="/learn-notes/browser/wechat.md" class="" aria-label="微信公众号经验记录"><!--[--><!--]--> 微信公众号经验记录 <!--[--><!--]--></a></li><!--]--></ul></div></div><div class="navbar-item"><a class="external-link" href="https://github.com/sanlangguo/learn-notes" rel="noopener noreferrer" target="_blank" aria-label="github"><!--[--><!--]--> github <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading"> <!----></p><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#前序遍历" class="router-link-active router-link-exact-active sidebar-item" aria-label="前序遍历"><!--[--><!--]--> 前序遍历 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#中序遍历" class="router-link-active router-link-exact-active sidebar-item" aria-label="中序遍历"><!--[--><!--]--> 中序遍历 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#后序遍历" class="router-link-active router-link-exact-active sidebar-item" aria-label="后序遍历"><!--[--><!--]--> 后序遍历 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#_94-二叉树的中序遍历" class="router-link-active router-link-exact-active sidebar-item" aria-label="94. 二叉树的中序遍历"><!--[--><!--]--> 94. 二叉树的中序遍历 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#_104-二叉树的最大深度" class="router-link-active router-link-exact-active sidebar-item" aria-label="104. 二叉树的最大深度"><!--[--><!--]--> 104. 二叉树的最大深度 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#_226-翻转二叉树" class="router-link-active router-link-exact-active sidebar-item" aria-label="226. 翻转二叉树"><!--[--><!--]--> 226. 翻转二叉树 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#_101-对称二叉树" class="router-link-active router-link-exact-active sidebar-item" aria-label="101. 对称二叉树"><!--[--><!--]--> 101. 对称二叉树 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#_543-二叉树的直径" class="router-link-active router-link-exact-active sidebar-item" aria-label="543. 二叉树的直径"><!--[--><!--]--> 543. 二叉树的直径 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#_102-二叉树的层序遍历" class="router-link-active router-link-exact-active sidebar-item" aria-label="102. 二叉树的层序遍历"><!--[--><!--]--> 102. 二叉树的层序遍历 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#_108-将有序数组转换为二叉搜索树" class="router-link-active router-link-exact-active sidebar-item" aria-label="108. 将有序数组转换为二叉搜索树"><!--[--><!--]--> 108. 将有序数组转换为二叉搜索树 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#_98-验证二叉搜索树" class="router-link-active router-link-exact-active sidebar-item" aria-label="98. 验证二叉搜索树"><!--[--><!--]--> 98. 验证二叉搜索树 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#_230-二叉搜索树中第k小的元素" class="router-link-active router-link-exact-active sidebar-item" aria-label="230. 二叉搜索树中第K小的元素"><!--[--><!--]--> 230. 二叉搜索树中第K小的元素 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#_199-二叉树的右视图" class="router-link-active router-link-exact-active sidebar-item" aria-label="199. 二叉树的右视图"><!--[--><!--]--> 199. 二叉树的右视图 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#_114-二叉树展开为链表" class="router-link-active router-link-exact-active sidebar-item" aria-label="114. 二叉树展开为链表"><!--[--><!--]--> 114. 二叉树展开为链表 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#_105-从前序与中序遍历序列构造二叉树" class="router-link-active router-link-exact-active sidebar-item" aria-label="105. 从前序与中序遍历序列构造二叉树"><!--[--><!--]--> 105. 从前序与中序遍历序列构造二叉树 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#_437-路径总和-iii" class="router-link-active router-link-exact-active sidebar-item" aria-label="437. 路径总和 III"><!--[--><!--]--> 437. 路径总和 III <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#_236-二叉树的最近公共祖先" class="router-link-active router-link-exact-active sidebar-item" aria-label="236. 二叉树的最近公共祖先"><!--[--><!--]--> 236. 二叉树的最近公共祖先 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/learn-notes/algorithm/binary-tree.html#_124-二叉树中的最大路径和" class="router-link-active router-link-exact-active sidebar-item" aria-label="124. 二叉树中的最大路径和"><!--[--><!--]--> 124. 二叉树中的最大路径和 <!--[--><!--]--></a><!----></li><!--]--></ul></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><!--]--><div><h3 id="前序遍历" tabindex="-1"><a class="header-anchor" href="#前序遍历" aria-hidden="true">#</a> 前序遍历</h3><ul><li><strong>场景：</strong><ul><li>复制一棵二叉树</li><li>计算二叉树的节点数</li><li>判断两棵二叉树是否相等</li><li>序列化二叉树</li></ul></li></ul><h3 id="中序遍历" tabindex="-1"><a class="header-anchor" href="#中序遍历" aria-hidden="true">#</a> 中序遍历</h3><ul><li><strong>场景：</strong><ul><li>输出二叉树中的元素按升序排列</li><li>查找二叉树中的第 k 个最小元素</li><li>将二叉搜索树转换为双向链表</li><li>验证二叉搜索树</li></ul></li></ul><h3 id="后序遍历" tabindex="-1"><a class="header-anchor" href="#后序遍历" aria-hidden="true">#</a> 后序遍历</h3><ul><li><strong>场景：</strong><ul><li>释放二叉树中的内存</li><li>计算二叉树的高度</li><li>检查二叉树是否为完全二叉树</li><li>反转二叉树</li></ul></li></ul><p>使用前序求的就是深度，使用后序求的是高度。</p><ul><li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）</li><li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）</li></ul><p><strong>二叉树的高度</strong></p><ul><li>**定义：**二叉树中从根节点到最深叶节点的最长路径上的节点数。</li><li>**计算方法：**从根节点开始，递归地计算左子树和右子树的高度，取较大值加 1。</li><li><strong>特点：</strong><ul><li>表示树的整体大小。</li><li>衡量树的平衡性。</li></ul></li></ul><p><strong>二叉树的深度</strong></p><ul><li>**定义：**二叉树中从根节点到任意叶节点的最长路径上的节点数。</li><li>**计算方法：**从根节点开始，递归地计算左子树和右子树的深度，取较大值。</li><li><strong>特点：</strong><ul><li>表示树中节点的最大深度。</li><li>衡量树的复杂性。</li></ul></li></ul><p><strong>区别</strong></p><table><thead><tr><th>特征</th><th>二叉树的高度</th><th>二叉树的深度</th></tr></thead><tbody><tr><td>定义</td><td>根节点到最深叶节点的路径长度</td><td>根节点到任意叶节点的路径长度</td></tr><tr><td>计算方法</td><td>递归计算左右子树的高度</td><td>递归计算左右子树的深度</td></tr><tr><td>特点</td><td>表示树的整体大小和平衡性</td><td>表示树中节点的最大深度和复杂性</td></tr><tr><td>范围</td><td>高度 &gt;= 深度</td><td>高度 &gt;= 深度</td></tr><tr><td>对于完全二叉树</td><td>高度 = 深度</td><td>高度 = 深度</td></tr></tbody></table><p><strong>示例</strong></p><p>考虑以下二叉树：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>        1
       / \
      2   3
     / \   \
    4   5   6
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>**高度：**3（从根节点到叶节点 6 的路径）</li><li>**深度：**2（从根节点到叶节点 4 或 5 的路径）</li></ul><h3 id="_94-二叉树的中序遍历" tabindex="-1"><a class="header-anchor" href="#_94-二叉树的中序遍历" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener noreferrer">94. 二叉树的中序遍历<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&amp;envId=top-100-liked#" target="_blank" rel="noopener noreferrer">思路<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><strong>简单</strong></p><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>输入：root = <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token null keyword">null</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>题解</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">inorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">const</span> <span class="token function-variable function">dp</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> node
    <span class="token function">dp</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
    <span class="token function">dp</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">dp</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_104-二叉树的最大深度" tabindex="-1"><a class="header-anchor" href="#_104-二叉树的最大深度" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener noreferrer">104. 二叉树的最大深度<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><strong>简单</strong></p><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [3,9,20,null,null,15,7]
输出：3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>题解思路</p><p>采用前序和后序都可以</p></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">maxDepth</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// 如果根节点为空，则返回 0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 递归计算左子树的最大深度</span>
    <span class="token keyword">let</span> leftDepth <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 递归计算右子树的最大深度</span>
    <span class="token keyword">let</span> rightDepth <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回左子树和右子树的最大深度加上 1（根节点）</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftDepth<span class="token punctuation">,</span> rightDepth<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_226-翻转二叉树" tabindex="-1"><a class="header-anchor" href="#_226-翻转二叉树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/invert-binary-tree/" target="_blank" rel="noopener noreferrer">226. 翻转二叉树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><strong>简单</strong></p><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>输入：root = <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
输出：<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解题思路 具体来说，我们首先检查根节点是否为空。如果为空，则返回空。否则，我们递归地翻转左右子树。然后，我们交换左右子树。最后，我们返回翻转后的二叉树的根节点。</li><li>时间复杂度 这道题的时间复杂度是 O(n)，其中 n 是二叉树的节点数。这是因为我们必须遍历二叉树中的每个节点。</li><li>空间复杂度 这道题的空间复杂度是 O(h)，其中 h 是二叉树的高度。这是因为我们必须使用递归调用栈。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>

代码实现
代码实现非常简单。我们首先检查根节点是否为空。如果为空，则返回空。否则，我们递归地翻转左右子树。然后，我们交换左右子树。最后，我们返回翻转后的二叉树的根节点。

<span class="token doc-comment comment">/**
 * 翻转一棵二叉树。
 *
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span> 二叉树的根节点。
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> 翻转后的二叉树的根节点。
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">invertTree</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果根节点为空，则返回空。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token comment">// 递归翻转左右子树。</span>
    <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 交换左右子树。</span>
    root<span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>
    root<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>

    <span class="token comment">// 返回翻转后的二叉树的根节点。</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_101-对称二叉树" tabindex="-1"><a class="header-anchor" href="#_101-对称二叉树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/symmetric-tree/" target="_blank" rel="noopener noreferrer">101. 对称二叉树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><strong>简单</strong></p><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><p><img src="https://pic.leetcode.cn/1698026966-JDYPDU-image.png" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [1,2,2,3,4,4,3]
输出：true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>解题思路：</strong></li></ul><p>要判断一棵二叉树是否对称，我们可以使用递归的方法。具体步骤如下：</p><ol><li>**基线情况：**如果树为空或只有一个节点，则它是对称的。</li><li><strong>递归情况：</strong><ul><li>检查左子树和右子树是否对称。</li><li>检查左子树的左子树和右子树的右子树是否对称。</li><li>检查左子树的右子树和右子树的左子树是否对称。</li></ul></li></ol><ul><li>题解</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>boolean<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">isSymmetric</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">const</span> <span class="token function-variable function">dps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> right <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> left<span class="token punctuation">.</span>val <span class="token operator">!=</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token keyword">return</span> <span class="token function">dps</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span> right<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">dps</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span> right<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">dps</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> root<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_543-二叉树的直径" tabindex="-1"><a class="header-anchor" href="#_543-二叉树的直径" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/diameter-of-binary-tree/" target="_blank" rel="noopener noreferrer">543. 二叉树的直径<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><strong>简单</strong></p><p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p><p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p><p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>解题思路</p><p>所谓二叉树的直径，就是左右子树的最大深度之和，那么直接的想法是对每个节点计算左右子树的最大高度，得出每个节点的直径，从而得出最大的那个直径。</p></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">diameterOfBinaryTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 初始化最大直径为0</span>
    <span class="token keyword">let</span> max <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment">// 定义深度优先搜索函数</span>
    <span class="token keyword">const</span> <span class="token function-variable function">dps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果节点为空，返回0</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token comment">// 递归计算左子树深度</span>
        <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">dps</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token comment">// 递归计算右子树深度</span>
        <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">dps</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token comment">// 更新最大直径</span>
        max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">,</span> max<span class="token punctuation">)</span>
        <span class="token comment">// 返回当前节点的深度</span>
        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 调用深度优先搜索函数</span>
    <span class="token function">dps</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
    <span class="token comment">// 返回最大直径</span>
    <span class="token keyword">return</span> max
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_102-二叉树的层序遍历" tabindex="-1"><a class="header-anchor" href="#_102-二叉树的层序遍历" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener noreferrer">102. 二叉树的层序遍历<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><strong>中等</strong></p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>解题思路：</strong></li></ul><ol><li>初始化结果集 <code>res</code> 和队列 <code>queue</code>。</li><li>如果根节点为空，直接返回结果集。</li><li>将根节点加入队列。</li><li>循环队列，直到队列为空： <ul><li>创建一个空数组 <code>level</code> 来存储当前层的节点值。</li><li>记录当前层的节点数量 <code>length</code>。</li><li>遍历当前层的每个节点： <ul><li>取出队首节点 <code>node</code>。</li><li>将 <code>node</code> 的值加入 <code>level</code>。</li><li>如果 <code>node</code> 的左子节点不为空，加入队列。</li><li>如果 <code>node</code> 的右子节点不为空，加入队列。</li></ul></li><li>将 <code>level</code> 加入结果集 <code>res</code>。</li></ul></li><li>返回结果集 <code>res</code>。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) <span class="token punctuation">{</span>
 *     this.val = val;
 *     this.left = this.right = null;
 * <span class="token punctuation">}</span>
 */</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">levelOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 结果集</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> 
    <span class="token comment">// 队列</span>
    queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment">// 如果根节点为空，直接返回结果集</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res
    <span class="token comment">// 将根节点加入队列</span>
    queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>
    <span class="token comment">// 只要队列不为空，就继续循环</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 每一层的节点值</span>
        <span class="token keyword">let</span> level <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token comment">// 当前层的节点数量</span>
        <span class="token keyword">let</span> length <span class="token operator">=</span> queue<span class="token punctuation">.</span>length
        <span class="token comment">// 遍历当前层的每个节点</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 取出队首节点</span>
            <span class="token keyword">let</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment">// 将节点值加入当前层</span>
            level<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            <span class="token comment">// 如果左子节点不为空，加入队列</span>
            node<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            <span class="token comment">// 如果右子节点不为空，加入队列</span>
            node<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 将当前层加入结果集</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回结果集</span>
    <span class="token keyword">return</span> res
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_108-将有序数组转换为二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_108-将有序数组转换为二叉搜索树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener noreferrer">108. 将有序数组转换为二叉搜索树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><strong>简单</strong></p><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵平衡二叉搜索树。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>解题思路：</strong></li></ul><p>我们可以使用分治法来解决这个问题。</p><ol><li>**找到数组的中间元素：**中间元素将成为二叉搜索树的根节点。</li><li>**递归地将数组的左半部分转换为左子树，右半部分转换为右子树：**这将确保二叉搜索树是高度平衡的。</li><li>**将左子树和右子树连接到根节点：**这将完成二叉搜索树的构建。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span> <span class="token parameter">nums</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">sortedArrayToBST</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果数组为空，则返回 null</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>

  <span class="token comment">// 找到数组的中间索引</span>
  <span class="token keyword">const</span> mid <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">&gt;&gt;</span> <span class="token number">1</span>

  <span class="token comment">// 创建一个新的 TreeNode，值为中间索引处的元素</span>
  <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>

  <span class="token comment">// 递归创建左子树和右子树</span>
  root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">)</span>
  root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token comment">// 返回 BST 的根节点</span>
  <span class="token keyword">return</span> root
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_98-验证二叉搜索树" tabindex="-1"><a class="header-anchor" href="#_98-验证二叉搜索树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/validate-binary-search-tree/" target="_blank" rel="noopener noreferrer">98. 验证二叉搜索树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><strong>中等</strong></p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含小于 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [2,1,3]
输出：true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解题思路 <ol><li>通过递归遍历二叉树的每个节点，同时维护一个变量 pre 来保存前一个节点的值</li><li>然后判断当前节点的值是否大于前一个节点的值，以此来判断二叉树是否为二叉搜索树。</li><li>左子树所有节点的值都小于当前节点的值，</li><li>右子树所有节点的值都大于当前节点的值。</li><li>最终返回整棵树是否为二叉搜索树的结果。</li></ol></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>

<span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>boolean<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">isValidBST</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 初始化一个变量 pre 用于保存前一个节点的值</span>
    <span class="token keyword">const</span> <span class="token function-variable function">dp</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 定义一个递归函数 dp，用于判断二叉树是否为二叉搜索树</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token comment">// 如果节点为空，返回 true</span>
        <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">dp</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token comment">// 递归判断左子树</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> pre <span class="token operator">&gt;=</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span> <span class="token comment">// 如果前一个节点的值大于等于当前节点的值，返回 false</span>
        pre <span class="token operator">=</span> node<span class="token punctuation">.</span>val <span class="token comment">// 更新前一个节点的值为当前节点的值</span>
        <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">dp</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token comment">// 递归判断右子树</span>
        <span class="token keyword">return</span> left <span class="token operator">&amp;&amp;</span> right <span class="token comment">// 返回左右子树是否都为二叉搜索树</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">dp</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token comment">// 返回调用 dp 函数处理根节点的结果</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_230-二叉搜索树中第k小的元素" tabindex="-1"><a class="header-anchor" href="#_230-二叉搜索树中第k小的元素" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener noreferrer">230. 二叉搜索树中第K小的元素<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><strong>中等</strong></p><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [3,1,4,null,2], k = 1
输出：1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解题思路</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span> <span class="token parameter">k</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">kthSmallest</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 初始化变量 res 为 0，index 为 0</span>
    <span class="token keyword">const</span> <span class="token function-variable function">dps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 定义一个深度优先搜索函数 dps，接收一个节点 node 和整数 k</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果当前节点有左子节点</span>
            <span class="token function">dps</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token comment">// 递归调用 dps 函数，传入左子节点和 k</span>
        <span class="token punctuation">}</span>
        index<span class="token operator">++</span> <span class="token comment">// 索引加一</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">===</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果索引等于 k</span>
            <span class="token keyword">return</span> res <span class="token operator">=</span> node<span class="token punctuation">.</span>val <span class="token comment">// 将 res 设置为当前节点的值</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果当前节点有右子节点</span>
            <span class="token function">dps</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token comment">// 递归调用 dps 函数，传入右子节点和 k</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">dps</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token comment">// 调用深度优先搜索函数，传入根节点和 k</span>
    <span class="token keyword">return</span> res <span class="token comment">// 返回结果 res</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_199-二叉树的右视图" tabindex="-1"><a class="header-anchor" href="#_199-二叉树的右视图" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/binary-tree-right-side-view/" target="_blank" rel="noopener noreferrer">199. 二叉树的右视图<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><strong>中等</strong></p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">rightSideView</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">// 如果根节点为空，返回一个空数组</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>  <span class="token comment">// 定义结果数组 res 和辅助队列 queue，初始将根节点放入队列中</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 循环直到队列为空</span>
    <span class="token keyword">const</span> length <span class="token operator">=</span> queue<span class="token punctuation">.</span>length  <span class="token comment">// 获取当前队列的长度</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 遍历当前层的节点</span>
      <span class="token keyword">let</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 取出队首节点</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 如果当前节点是当前层的最后一个节点</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>  <span class="token comment">// 将当前节点的值存入结果数组 res 中</span>
      <span class="token punctuation">}</span>
      node<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>  <span class="token comment">// 如果当前节点有左子节点，则将左子节点加入队列中</span>
      node<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>  <span class="token comment">// 如果当前节点有右子节点，则将右子节点加入队列中</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res  <span class="token comment">// 返回存储了右视图节点值的结果数组 res</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_114-二叉树展开为链表" tabindex="-1"><a class="header-anchor" href="#_114-二叉树展开为链表" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener noreferrer">114. 二叉树展开为链表<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><strong>中等</strong></p><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin" target="_blank" rel="noopener noreferrer"><strong>先序遍历</strong><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 顺序相同。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = []
输出：[]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解题思路 <a href="https://labuladong.online/algo/slug.html?slug=flatten-binary-tree-to-linked-list" target="_blank" rel="noopener noreferrer"><strong>参考</strong><span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><p><strong>给 <code>flatten</code> 函数输入一个节点 <code>root</code>，那么以 <code>root</code> 为根的二叉树就会被拉平为一条链表</strong>。</p><p>如何利用这个定义来完成算法？你想想怎么把以 <code>root</code> 为根的二叉树拉平为一条链表？</p><p>很简单，以下流程：</p><p>1、将 <code>root</code> 的左子树和右子树拉平。</p><p>2、将 <code>root</code> 的右子树接到左子树下方，然后将整个左子树作为右子树。</p><p><img src="https://labuladong.github.io/pictures/二叉树系列/2.jpeg" alt="img"></p><p>至于如何把 <code>root</code> 的左右子树拉平，不用你操心，<code>flatten</code> 函数的定义就是这样，交给他做就行了。</p><p>把上面的逻辑翻译成代码，即可解决本题。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">flatten</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// base case</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">// 先递归拉平左右子树</span>
    <span class="token function">flatten</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">flatten</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/****后序遍历位置****/</span>
    <span class="token comment">// 1、左右子树已经被拉平成一条链表</span>
    <span class="token keyword">var</span> left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token keyword">var</span> right <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>

    <span class="token comment">// 2、将左子树作为右子树</span>
    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    root<span class="token punctuation">.</span>right <span class="token operator">=</span> left<span class="token punctuation">;</span>

    <span class="token comment">// 3、将原先的右子树接到当前右子树的末端</span>
    <span class="token keyword">var</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    p<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_105-从前序与中序遍历序列构造二叉树" tabindex="-1"><a class="header-anchor" href="#_105-从前序与中序遍历序列构造二叉树" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener noreferrer">105. 从前序与中序遍历序列构造二叉树<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><strong>中等</strong></p><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入: preorder = [-1], inorder = [-1]
输出: [-1]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解题思路 <a href="https://labuladong.online/algo/slug.html?slug=construct-binary-tree-from-preorder-and-inorder-traversal" target="_blank" rel="noopener noreferrer">参考<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><p><strong>构造二叉树，第一件事一定是找根节点，然后想办法构造左右子树</strong>。</p><p>二叉树的前序和中序遍历结果的特点如下：</p><p><img src="https://labuladong.github.io/pictures/二叉树系列2/1.jpeg" alt="img"></p><p>前序遍历结果第一个就是根节点的值，然后再根据中序遍历结果确定左右子树的节点。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span> <span class="token parameter">preorder</span>
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span> <span class="token parameter">inorder</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">buildTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">preorder<span class="token punctuation">,</span> inorder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 如果前序遍历数组为空，则返回空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>preorder<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>
    
    <span class="token comment">// 从前序遍历数组中获取根节点的值</span>
    <span class="token keyword">const</span> rootVal <span class="token operator">=</span> preorder<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token comment">// 在中序遍历数组中查找根节点值的索引</span>
    <span class="token keyword">const</span> rootIndex <span class="token operator">=</span> inorder<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span>
    
    <span class="token comment">// 创建一个根节点，值为根节点的值</span>
    <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span>
    
    <span class="token comment">// 递归构建左子树，使用前序遍历和中序遍历数组的左部分</span>
    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> rootIndex<span class="token punctuation">)</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> rootIndex<span class="token punctuation">)</span><span class="token punctuation">)</span>
    
    <span class="token comment">// 递归构建右子树，使用前序遍历和中序遍历数组的右部分</span>
    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>rootIndex<span class="token punctuation">)</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>rootIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    
    <span class="token comment">// 返回二叉树的根节点</span>
    <span class="token keyword">return</span> root
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_437-路径总和-iii" tabindex="-1"><a class="header-anchor" href="#_437-路径总和-iii" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/path-sum-iii/" target="_blank" rel="noopener noreferrer">437. 路径总和 III<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><a href="https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&amp;envId=top-100-liked#" target="_blank" rel="noopener noreferrer">思路<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>中等</p><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p><p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解题思路 <ol><li><p><strong>递归遍历</strong>：从树的根节点开始，递归地遍历每个节点。</p></li><li><p><strong>路径总和计算</strong>：对于每个节点，以该节点为起点，向下遍历所有可能的路径，计算路径和是否等于给定的目标值。</p></li><li><p><strong>辅助函数</strong>：可以编写一个辅助函数，用于计算以当前节点为起点的路径总和个数。在该函数中，可以使用递归来遍历以当前节点为根的子树，并不断累加路径和。</p></li><li><p><strong>前缀和</strong>：在遍历过程中，可以使用一个哈希表来记录从根节点到当前节点的路径和，以及每个路径和出现的次数。</p></li><li><p><strong>路径和判断</strong>：在更新路径和的同时，查看在哈希表中是否存在之前路径和加上或减去目标值的结果，若存在则说明存在符合条件的路径。</p></li><li><p><strong>统计路径总数</strong>：最终统计符合条件的路径总数，并返回结果。</p></li></ol></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">pathSum</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> sum</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用哈希表来记录路径和及其出现次数</span>
    <span class="token keyword">const</span> prefixSumCount <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// 定义递归函数，计算符合条件的路径总数</span>
    <span class="token keyword">const</span> <span class="token function-variable function">dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> currSum</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

        <span class="token comment">// 更新当前路径和</span>
        currSum <span class="token operator">+=</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        
        <span class="token comment">// 更新符合条件的路径总数</span>
        count <span class="token operator">+=</span> prefixSumCount<span class="token punctuation">[</span>currSum <span class="token operator">-</span> sum<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 更新当前路径和在哈希表中的出现次数</span>
        prefixSumCount<span class="token punctuation">[</span>currSum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>prefixSumCount<span class="token punctuation">[</span>currSum<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token comment">// 递归遍历左子树</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> currSum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 递归遍历右子树</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> currSum<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 回溯，将当前路径和在哈希表中的出现次数减一</span>
        prefixSumCount<span class="token punctuation">[</span>currSum<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 调用递归函数开始计算路径总数</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 返回符合条件的路径总数</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_236-二叉树的最近公共祖先" tabindex="-1"><a class="header-anchor" href="#_236-二叉树的最近公共祖先" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener noreferrer">236. 二叉树的最近公共祖先<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><strong>中等</strong></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin" target="_blank" rel="noopener noreferrer">百度百科<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解题思路</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>
<span class="token comment">// 寻找最近公共祖先的函数</span>
<span class="token keyword">var</span> <span class="token function-variable function">lowestCommonAncestor</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 边界条件：如果当前节点为 null 或者等于 p 或 q，则直接返回当前节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> root <span class="token operator">===</span> p <span class="token operator">||</span> root <span class="token operator">===</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 递归查找左子树和右子树</span>
    <span class="token keyword">var</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 根据左右子树的情况判断最近公共祖先</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> right <span class="token comment">// p 和 q 同在右子树，最近公共祖先为 right</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left  <span class="token comment">// p 和 q 同在左子树，最近公共祖先为 left</span>
    <span class="token keyword">return</span> root  <span class="token comment">// p 和 q 分别位于当前节点的左右子树，当前节点即为最近公共祖先</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_124-二叉树中的最大路径和" tabindex="-1"><a class="header-anchor" href="#_124-二叉树中的最大路径和" aria-hidden="true">#</a> <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener noreferrer">124. 二叉树中的最大路径和<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></h3><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&amp;envId=top-100-liked#" target="_blank" rel="noopener noreferrer">思路<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p><strong>困难</strong></p><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>
<span class="token keyword">var</span> <span class="token function-variable function">maxPathSum</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 定义函数 maxPathSum，接受根节点作为参数</span>
    <span class="token keyword">let</span> maxNum <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token constant">MIN_SAFE_INTEGER</span><span class="token punctuation">;</span> <span class="token comment">// 初始化最大路径和为 JavaScript 中表示的最小安全整数</span>
    <span class="token keyword">const</span> <span class="token function-variable function">dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 定义深度优先搜索函数 dfs，接受一个节点作为参数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 如果节点为空，返回0</span>
        <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归计算左子树的最大路径和</span>
        <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归计算右子树的最大路径和</span>
        <span class="token keyword">const</span> interNum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>right <span class="token operator">+</span> left <span class="token operator">+</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算经过当前节点的路径和</span>
        maxNum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxNum<span class="token punctuation">,</span> interNum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新最大路径和</span>
        <span class="token keyword">const</span> outNumer <span class="token operator">=</span> root<span class="token punctuation">.</span>val <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算以当前节点为根节点向上延伸的路径和</span>
        <span class="token keyword">return</span> outNumer <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> outNumer<span class="token punctuation">;</span> <span class="token comment">// 返回向上延伸的路径和，确保不为负数</span>
    <span class="token punctuation">}</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 dfs 函数开始遍历二叉树</span>
    <span class="token keyword">return</span> maxNum<span class="token punctuation">;</span> <span class="token comment">// 返回整棵二叉树中的最大路径和</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><!--[--><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: SanLangGuo@outlook.com">三郎过</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/learn-notes/assets/app-B-42ZPY7.js" defer></script>
  </body>
</html>
