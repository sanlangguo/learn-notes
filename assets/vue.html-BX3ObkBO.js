import{_ as a,r as o,o as s,c as i,a as e,b as r,d as n,e as h}from"./app-B-42ZPY7.js";const l={},d=e("h3",{id:"vue-react-区别",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#vue-react-区别","aria-hidden":"true"},"#"),r(" vue react 区别")],-1),u={href:"https://blog.csdn.net/xgangzai/article/details/115301290",target:"_blank",rel:"noopener noreferrer"},c=e("h3",{id:"vue响应式原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#vue响应式原理","aria-hidden":"true"},"#"),r(" vue响应式原理")],-1),_={href:"https://cn.vuejs.org/v2/guide/reactivity.html",target:"_blank",rel:"noopener noreferrer"},v=e("h3",{id:"vue文件编译原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#vue文件编译原理","aria-hidden":"true"},"#"),r(" vue文件编译原理")],-1),p={href:"https://forum.vuejs.org/t/vue-js-vue-js/60884",target:"_blank",rel:"noopener noreferrer"},f=h(`<h3 id="计算属性-vs-监听属性" tabindex="-1"><a class="header-anchor" href="#计算属性-vs-监听属性" aria-hidden="true">#</a> 计算属性 VS 监听属性</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>watch：监测的是属性值， 只要属性值发生变化，其都会触发执行回调函数来执行一系列操作。
computed：监测的是依赖值，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算。

计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="vue-data-为什么是一个函数" tabindex="-1"><a class="header-anchor" href="#vue-data-为什么是一个函数" aria-hidden="true">#</a> vue data 为什么是一个函数</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>  为了保证组件的独立性和可复用性，data 是一个函数，组件实例化的时候这个函数将会被调用，返回一个对象，计算机会给这个对象分配一个内存地址，你实例化几次，就分配几个内存地址，他们的地址都不一样，所以每个组件中的数据不会相互干扰，改变其中一个组件的状态，其它组件不变。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,4),b={href:"https://www.jianshu.com/p/b821d3401314",target:"_blank",rel:"noopener noreferrer"},g=e("br",null,null,-1),m={href:"https://axiu.me/coding/why-vue-component-data-must-be-function/",target:"_blank",rel:"noopener noreferrer"},x=e("h3",{id:"vue文件编译原理-常见面试题",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#vue文件编译原理-常见面试题","aria-hidden":"true"},"#"),r(" vue文件编译原理/常见面试题")],-1),E={href:"https://cloud.tencent.com/developer/article/1601614",target:"_blank",rel:"noopener noreferrer"},k={href:"https://github.com/berwin/Blog/issues/18",target:"_blank",rel:"noopener noreferrer"},w={href:"https://www.cnblogs.com/skywind/p/14653339.html#12-vuejs-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86",target:"_blank",rel:"noopener noreferrer"},B=e("h3",{id:"this-nexttick-原理-100次更新dem-执行一次-更新dom-为什么是异步的",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#this-nexttick-原理-100次更新dem-执行一次-更新dom-为什么是异步的","aria-hidden":"true"},"#"),r(" this.nextTick() 原理 100次更新dem 执行一次 (更新dom 为什么是异步的)")],-1),j={href:"https://github.com/berwin/Blog/issues/22",target:"_blank",rel:"noopener noreferrer"},A=e("h3",{id:"vue-router-hash-history-核心理解",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#vue-router-hash-history-核心理解","aria-hidden":"true"},"#"),r(" vue-router hash history 核心理解")],-1),V={href:"https://juejin.cn/post/6921965450742431758",target:"_blank",rel:"noopener noreferrer"},D={href:"https://www.jianshu.com/p/3b4abc20ae0f",target:"_blank",rel:"noopener noreferrer"},M=e("h3",{id:"vue3-watcher-原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#vue3-watcher-原理","aria-hidden":"true"},"#"),r(" vue3 watcher 原理")],-1),y={href:"https://originalix.github.io/2021/06/16/Vue3-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E5%8D%81-watch-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/#",target:"_blank",rel:"noopener noreferrer"},F=e("h3",{id:"为什么选用vuex-不用-object-的根本原因",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#为什么选用vuex-不用-object-的根本原因","aria-hidden":"true"},"#"),r(" 为什么选用vuex, 不用 object 的根本原因")],-1),O=e("p",null,"可以使用，vuex 提供的是一种完整的解决方案，看个人怎么选择，在团队开发当中，统一规范",-1),N={href:"https://vuex.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E6%88%91%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8-vuex%EF%BC%9F",target:"_blank",rel:"noopener noreferrer"},C=e("h3",{id:"vue3-哪些变化",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#vue3-哪些变化","aria-hidden":"true"},"#"),r(" vue3 哪些变化")],-1),R={href:"https://v3.cn.vuejs.org/guide/migration/introduction.html#%E6%A6%82%E8%A7%88",target:"_blank",rel:"noopener noreferrer"},z=e("h3",{id:"vue3-响应式原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#vue3-响应式原理","aria-hidden":"true"},"#"),r(" vue3 响应式原理")],-1),I={href:"https://juejin.cn/post/6858899262596448270#heading-21",target:"_blank",rel:"noopener noreferrer"},L=e("h3",{id:"vue-组件传值",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#vue-组件传值","aria-hidden":"true"},"#"),r(" vue 组件传值")],-1),S={href:"https://segmentfault.com/a/1190000022700216",target:"_blank",rel:"noopener noreferrer"},T=e("h3",{id:"vue3-组件挂载时",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#vue3-组件挂载时","aria-hidden":"true"},"#"),r(" Vue3 组件挂载时")],-1),W=e("ul",null,[e("li",null,"从高层面的视角看，Vue 组件挂载时会发生如下几件事：")],-1),Y=e("li",null,[e("strong",null,"编译"),r("：Vue 模板被编译为"),e("strong",null,"渲染函数"),r("：即用来返回虚拟 DOM 树的函数。这一步骤可以通过构建步骤提前完成，也可以通过使用运行时编译器即时完成。")],-1),Z=e("strong",null,"挂载",-1),$={href:"https://cn.vuejs.org/guide/extras/reactivity-in-depth.html",target:"_blank",rel:"noopener noreferrer"},q=e("li",null,[e("strong",null,"更新"),r("：当一个依赖发生变化后，副作用会重新运行，这时候会创建一个更新后的虚拟 DOM 树。运行时渲染器遍历这棵新树，将它与旧树进行比较，然后将必要的更新应用到真实 DOM 上去。")],-1),G=e("p",null,[e("img",{src:"https://cn.vuejs.org/assets/render-pipeline.sMZx_5WY.png",alt:"render pipeline"})],-1),H=e("h3",{id:"vue2-渲染的过程",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#vue2-渲染的过程","aria-hidden":"true"},"#"),r(" Vue2 渲染的过程")],-1),J=e("ol",null,[e("li",null,"通过new Vue 语句实例化 Vue 对象"),e("li",null,"挂载$mount 方法,通过自定义 Render 方法、template、el 等生成 Reder 函数，准备渲染内容"),e("li",null,"通过Watcher 进行依赖收集。"),e("li",null,"当数据发生变化时，执行 Render 函数并生成 VNode 对象"),e("li",null,"通过patch 方法，对比新旧 Node 对象，通过 DOM diff算法添加、修改、删除真正的 DOM元素。")],-1);function K(P,Q){const t=o("ExternalLinkIcon");return s(),i("div",null,[d,e("p",null,[e("a",u,[r("参考链接"),n(t)])]),c,e("p",null,[e("a",_,[r("vue官网解释"),n(t)])]),v,e("p",null,[e("a",p,[r("参考链接"),n(t)])]),f,e("p",null,[e("a",b,[r("参考链接"),n(t)]),g,e("a",m,[r("参考链接"),n(t)])]),x,e("p",null,[e("a",E,[r("Vue中的模板编译原理 01"),n(t)])]),e("p",null,[e("a",k,[r("Vue模板编译原理 02"),n(t)])]),e("p",null,[e("a",w,[r("常见面试题"),n(t)])]),B,e("p",null,[e("a",j,[r("参考链接"),n(t)])]),A,e("p",null,[e("a",V,[r("参考链接"),n(t)])]),e("p",null,[e("a",D,[r("参考链接"),n(t)])]),M,e("p",null,[e("a",y,[r("参考链接"),n(t)])]),F,O,e("p",null,[e("a",N,[r("参考链接"),n(t)])]),C,e("p",null,[e("a",R,[r("参考链接"),n(t)])]),z,e("p",null,[e("a",I,[r("参考链接"),n(t)])]),L,e("p",null,[e("a",S,[r("vue组件之间相互传值的方式"),n(t)])]),T,W,e("ol",null,[Y,e("li",null,[Z,r("：运行时渲染器调用渲染函数，遍历返回的虚拟 DOM 树，并基于它创建实际的 DOM 节点。这一步会作为"),e("a",$,[r("响应式副作用"),n(t)]),r("执行，因此它会追踪其中所用到的所有响应式依赖。")]),q]),G,H,J])}const X=a(l,[["render",K],["__file","vue.html.vue"]]);export{X as default};
