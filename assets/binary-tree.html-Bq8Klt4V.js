import{_ as p,r as o,o as l,c,a as n,b as s,d as e,e as t}from"./app-B-42ZPY7.js";const i={},r=t(`<h3 id="前序遍历" tabindex="-1"><a class="header-anchor" href="#前序遍历" aria-hidden="true">#</a> 前序遍历</h3><ul><li><strong>场景：</strong><ul><li>复制一棵二叉树</li><li>计算二叉树的节点数</li><li>判断两棵二叉树是否相等</li><li>序列化二叉树</li></ul></li></ul><h3 id="中序遍历" tabindex="-1"><a class="header-anchor" href="#中序遍历" aria-hidden="true">#</a> 中序遍历</h3><ul><li><strong>场景：</strong><ul><li>输出二叉树中的元素按升序排列</li><li>查找二叉树中的第 k 个最小元素</li><li>将二叉搜索树转换为双向链表</li><li>验证二叉搜索树</li></ul></li></ul><h3 id="后序遍历" tabindex="-1"><a class="header-anchor" href="#后序遍历" aria-hidden="true">#</a> 后序遍历</h3><ul><li><strong>场景：</strong><ul><li>释放二叉树中的内存</li><li>计算二叉树的高度</li><li>检查二叉树是否为完全二叉树</li><li>反转二叉树</li></ul></li></ul><p>使用前序求的就是深度，使用后序求的是高度。</p><ul><li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）</li><li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）</li></ul><p><strong>二叉树的高度</strong></p><ul><li>**定义：**二叉树中从根节点到最深叶节点的最长路径上的节点数。</li><li>**计算方法：**从根节点开始，递归地计算左子树和右子树的高度，取较大值加 1。</li><li><strong>特点：</strong><ul><li>表示树的整体大小。</li><li>衡量树的平衡性。</li></ul></li></ul><p><strong>二叉树的深度</strong></p><ul><li>**定义：**二叉树中从根节点到任意叶节点的最长路径上的节点数。</li><li>**计算方法：**从根节点开始，递归地计算左子树和右子树的深度，取较大值。</li><li><strong>特点：</strong><ul><li>表示树中节点的最大深度。</li><li>衡量树的复杂性。</li></ul></li></ul><p><strong>区别</strong></p><table><thead><tr><th>特征</th><th>二叉树的高度</th><th>二叉树的深度</th></tr></thead><tbody><tr><td>定义</td><td>根节点到最深叶节点的路径长度</td><td>根节点到任意叶节点的路径长度</td></tr><tr><td>计算方法</td><td>递归计算左右子树的高度</td><td>递归计算左右子树的深度</td></tr><tr><td>特点</td><td>表示树的整体大小和平衡性</td><td>表示树中节点的最大深度和复杂性</td></tr><tr><td>范围</td><td>高度 &gt;= 深度</td><td>高度 &gt;= 深度</td></tr><tr><td>对于完全二叉树</td><td>高度 = 深度</td><td>高度 = 深度</td></tr></tbody></table><p><strong>示例</strong></p><p>考虑以下二叉树：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>        1
       / \\
      2   3
     / \\   \\
    4   5   6
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>**高度：**3（从根节点到叶节点 6 的路径）</li><li>**深度：**2（从根节点到叶节点 4 或 5 的路径）</li></ul>`,18),u={id:"_94-二叉树的中序遍历",tabindex:"-1"},d=n("a",{class:"header-anchor",href:"#_94-二叉树的中序遍历","aria-hidden":"true"},"#",-1),k={href:"https://leetcode.cn/problems/binary-tree-inorder-traversal/",target:"_blank",rel:"noopener noreferrer"},v={href:"https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked#",target:"_blank",rel:"noopener noreferrer"},m=t(`<p><strong>简单</strong></p><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>输入：root = <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token null keyword">null</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
输出：<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>题解</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">inorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">const</span> <span class="token function-variable function">dp</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> node
    <span class="token function">dp</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
    <span class="token function">dp</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">dp</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7),b={id:"_104-二叉树的最大深度",tabindex:"-1"},g=n("a",{class:"header-anchor",href:"#_104-二叉树的最大深度","aria-hidden":"true"},"#",-1),h={href:"https://leetcode.cn/problems/maximum-depth-of-binary-tree/",target:"_blank",rel:"noopener noreferrer"},f=t(`<p><strong>简单</strong></p><p>给定一个二叉树 <code>root</code> ，返回其最大深度。</p><p>二叉树的 <strong>最大深度</strong> 是指从根节点到最远叶子节点的最长路径上的节点数。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [3,9,20,null,null,15,7]
输出：3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>题解思路</p><p>采用前序和后序都可以</p></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">maxDepth</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">// 如果根节点为空，则返回 0</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 递归计算左子树的最大深度</span>
    <span class="token keyword">let</span> leftDepth <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 递归计算右子树的最大深度</span>
    <span class="token keyword">let</span> rightDepth <span class="token operator">=</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 返回左子树和右子树的最大深度加上 1（根节点）</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>leftDepth<span class="token punctuation">,</span> rightDepth<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8),y={id:"_226-翻转二叉树",tabindex:"-1"},_=n("a",{class:"header-anchor",href:"#_226-翻转二叉树","aria-hidden":"true"},"#",-1),w={href:"https://leetcode.cn/problems/invert-binary-tree/",target:"_blank",rel:"noopener noreferrer"},x=t(`<p><strong>简单</strong></p><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="img"></p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>输入：root = <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
输出：<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解题思路 具体来说，我们首先检查根节点是否为空。如果为空，则返回空。否则，我们递归地翻转左右子树。然后，我们交换左右子树。最后，我们返回翻转后的二叉树的根节点。</li><li>时间复杂度 这道题的时间复杂度是 O(n)，其中 n 是二叉树的节点数。这是因为我们必须遍历二叉树中的每个节点。</li><li>空间复杂度 这道题的空间复杂度是 O(h)，其中 h 是二叉树的高度。这是因为我们必须使用递归调用栈。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>

代码实现
代码实现非常简单。我们首先检查根节点是否为空。如果为空，则返回空。否则，我们递归地翻转左右子树。然后，我们交换左右子树。最后，我们返回翻转后的二叉树的根节点。

<span class="token doc-comment comment">/**
 * 翻转一棵二叉树。
 *
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span> 二叉树的根节点。
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> 翻转后的二叉树的根节点。
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">invertTree</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果根节点为空，则返回空。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token comment">// 递归翻转左右子树。</span>
    <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">invertTree</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 交换左右子树。</span>
    root<span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>
    root<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>

    <span class="token comment">// 返回翻转后的二叉树的根节点。</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7),j={id:"_101-对称二叉树",tabindex:"-1"},T=n("a",{class:"header-anchor",href:"#_101-对称二叉树","aria-hidden":"true"},"#",-1),N={href:"https://leetcode.cn/problems/symmetric-tree/",target:"_blank",rel:"noopener noreferrer"},S=t(`<p><strong>简单</strong></p><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><p><img src="https://pic.leetcode.cn/1698026966-JDYPDU-image.png" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [1,2,2,3,4,4,3]
输出：true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>解题思路：</strong></li></ul><p>要判断一棵二叉树是否对称，我们可以使用递归的方法。具体步骤如下：</p><ol><li>**基线情况：**如果树为空或只有一个节点，则它是对称的。</li><li><strong>递归情况：</strong><ul><li>检查左子树和右子树是否对称。</li><li>检查左子树的左子树和右子树的右子树是否对称。</li><li>检查左子树的右子树和右子树的左子树是否对称。</li></ul></li></ol><ul><li>题解</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>boolean<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">isSymmetric</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">const</span> <span class="token function-variable function">dps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> right <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> left<span class="token punctuation">.</span>val <span class="token operator">!=</span> right<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span>
        <span class="token keyword">return</span> <span class="token function">dps</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>left<span class="token punctuation">,</span> right<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">dps</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span>right<span class="token punctuation">,</span> right<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">dps</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> root<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,10),q={id:"_543-二叉树的直径",tabindex:"-1"},D=n("a",{class:"header-anchor",href:"#_543-二叉树的直径","aria-hidden":"true"},"#",-1),E={href:"https://leetcode.cn/problems/diameter-of-binary-tree/",target:"_blank",rel:"noopener noreferrer"},I=t(`<p><strong>简单</strong></p><p>给你一棵二叉树的根节点，返回该树的 <strong>直径</strong> 。</p><p>二叉树的 <strong>直径</strong> 是指树中任意两个节点之间最长路径的 <strong>长度</strong> 。这条路径可能经过也可能不经过根节点 <code>root</code> 。</p><p>两节点之间路径的 <strong>长度</strong> 由它们之间边数表示。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>解题思路</p><p>所谓二叉树的直径，就是左右子树的最大深度之和，那么直接的想法是对每个节点计算左右子树的最大高度，得出每个节点的直径，从而得出最大的那个直径。</p></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">diameterOfBinaryTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 初始化最大直径为0</span>
    <span class="token keyword">let</span> max <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment">// 定义深度优先搜索函数</span>
    <span class="token keyword">const</span> <span class="token function-variable function">dps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果节点为空，返回0</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span>
        <span class="token comment">// 递归计算左子树深度</span>
        <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">dps</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        <span class="token comment">// 递归计算右子树深度</span>
        <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">dps</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token comment">// 更新最大直径</span>
        max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">,</span> max<span class="token punctuation">)</span>
        <span class="token comment">// 返回当前节点的深度</span>
        <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 调用深度优先搜索函数</span>
    <span class="token function">dps</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
    <span class="token comment">// 返回最大直径</span>
    <span class="token keyword">return</span> max
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,9),B={id:"_102-二叉树的层序遍历",tabindex:"-1"},C=n("a",{class:"header-anchor",href:"#_102-二叉树的层序遍历","aria-hidden":"true"},"#",-1),A={href:"https://leetcode.cn/problems/binary-tree-level-order-traversal/",target:"_blank",rel:"noopener noreferrer"},V=t(`<p><strong>中等</strong></p><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>解题思路：</strong></li></ul><ol><li>初始化结果集 <code>res</code> 和队列 <code>queue</code>。</li><li>如果根节点为空，直接返回结果集。</li><li>将根节点加入队列。</li><li>循环队列，直到队列为空： <ul><li>创建一个空数组 <code>level</code> 来存储当前层的节点值。</li><li>记录当前层的节点数量 <code>length</code>。</li><li>遍历当前层的每个节点： <ul><li>取出队首节点 <code>node</code>。</li><li>将 <code>node</code> 的值加入 <code>level</code>。</li><li>如果 <code>node</code> 的左子节点不为空，加入队列。</li><li>如果 <code>node</code> 的右子节点不为空，加入队列。</li></ul></li><li>将 <code>level</code> 加入结果集 <code>res</code>。</li></ul></li><li>返回结果集 <code>res</code>。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) <span class="token punctuation">{</span>
 *     this.val = val;
 *     this.left = this.right = null;
 * <span class="token punctuation">}</span>
 */</span>

<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">levelOrder</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 结果集</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> 
    <span class="token comment">// 队列</span>
    queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment">// 如果根节点为空，直接返回结果集</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> res
    <span class="token comment">// 将根节点加入队列</span>
    queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>
    <span class="token comment">// 只要队列不为空，就继续循环</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 每一层的节点值</span>
        <span class="token keyword">let</span> level <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token comment">// 当前层的节点数量</span>
        <span class="token keyword">let</span> length <span class="token operator">=</span> queue<span class="token punctuation">.</span>length
        <span class="token comment">// 遍历当前层的每个节点</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 取出队首节点</span>
            <span class="token keyword">let</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment">// 将节点值加入当前层</span>
            level<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
            <span class="token comment">// 如果左子节点不为空，加入队列</span>
            node<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
            <span class="token comment">// 如果右子节点不为空，加入队列</span>
            node<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 将当前层加入结果集</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 返回结果集</span>
    <span class="token keyword">return</span> res
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8),M={id:"_108-将有序数组转换为二叉搜索树",tabindex:"-1"},O=n("a",{class:"header-anchor",href:"#_108-将有序数组转换为二叉搜索树","aria-hidden":"true"},"#",-1),F={href:"https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/",target:"_blank",rel:"noopener noreferrer"},P=t(`<p><strong>简单</strong></p><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵平衡二叉搜索树。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>解题思路：</strong></li></ul><p>我们可以使用分治法来解决这个问题。</p><ol><li>**找到数组的中间元素：**中间元素将成为二叉搜索树的根节点。</li><li>**递归地将数组的左半部分转换为左子树，右半部分转换为右子树：**这将确保二叉搜索树是高度平衡的。</li><li>**将左子树和右子树连接到根节点：**这将完成二叉搜索树的构建。</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span> <span class="token parameter">nums</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">sortedArrayToBST</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">nums</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果数组为空，则返回 null</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>

  <span class="token comment">// 找到数组的中间索引</span>
  <span class="token keyword">const</span> mid <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">&gt;&gt;</span> <span class="token number">1</span>

  <span class="token comment">// 创建一个新的 TreeNode，值为中间索引处的元素</span>
  <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>

  <span class="token comment">// 递归创建左子树和右子树</span>
  root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">)</span>
  root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">sortedArrayToBST</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token comment">// 返回 BST 的根节点</span>
  <span class="token keyword">return</span> root
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,9),J={id:"_98-验证二叉搜索树",tabindex:"-1"},L=n("a",{class:"header-anchor",href:"#_98-验证二叉搜索树","aria-hidden":"true"},"#",-1),G={href:"https://leetcode.cn/problems/validate-binary-search-tree/",target:"_blank",rel:"noopener noreferrer"},K=t(`<p><strong>中等</strong></p><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含小于 当前节点的数。</li><li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [2,1,3]
输出：true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解题思路 <ol><li>通过递归遍历二叉树的每个节点，同时维护一个变量 pre 来保存前一个节点的值</li><li>然后判断当前节点的值是否大于前一个节点的值，以此来判断二叉树是否为二叉搜索树。</li><li>左子树所有节点的值都小于当前节点的值，</li><li>右子树所有节点的值都大于当前节点的值。</li><li>最终返回整棵树是否为二叉搜索树的结果。</li></ol></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>

<span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>boolean<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">isValidBST</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> pre <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">// 初始化一个变量 pre 用于保存前一个节点的值</span>
    <span class="token keyword">const</span> <span class="token function-variable function">dp</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 定义一个递归函数 dp，用于判断二叉树是否为二叉搜索树</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span> <span class="token comment">// 如果节点为空，返回 true</span>
        <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">dp</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token comment">// 递归判断左子树</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> pre <span class="token operator">&gt;=</span> node<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span> <span class="token comment">// 如果前一个节点的值大于等于当前节点的值，返回 false</span>
        pre <span class="token operator">=</span> node<span class="token punctuation">.</span>val <span class="token comment">// 更新前一个节点的值为当前节点的值</span>
        <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">dp</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token comment">// 递归判断右子树</span>
        <span class="token keyword">return</span> left <span class="token operator">&amp;&amp;</span> right <span class="token comment">// 返回左右子树是否都为二叉搜索树</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">dp</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token comment">// 返回调用 dp 函数处理根节点的结果</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,9),R={id:"_230-二叉搜索树中第k小的元素",tabindex:"-1"},U=n("a",{class:"header-anchor",href:"#_230-二叉搜索树中第k小的元素","aria-hidden":"true"},"#",-1),Y={href:"https://leetcode.cn/problems/kth-smallest-element-in-a-bst/",target:"_blank",rel:"noopener noreferrer"},z=t(`<p><strong>中等</strong></p><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [3,1,4,null,2], k = 1
输出：1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [5,3,6,2,4,null,null,1], k = 3
输出：3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解题思路</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span> <span class="token parameter">k</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">kthSmallest</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> index <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 初始化变量 res 为 0，index 为 0</span>
    <span class="token keyword">const</span> <span class="token function-variable function">dps</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> k</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 定义一个深度优先搜索函数 dps，接收一个节点 node 和整数 k</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果当前节点有左子节点</span>
            <span class="token function">dps</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token comment">// 递归调用 dps 函数，传入左子节点和 k</span>
        <span class="token punctuation">}</span>
        index<span class="token operator">++</span> <span class="token comment">// 索引加一</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">===</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果索引等于 k</span>
            <span class="token keyword">return</span> res <span class="token operator">=</span> node<span class="token punctuation">.</span>val <span class="token comment">// 将 res 设置为当前节点的值</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果当前节点有右子节点</span>
            <span class="token function">dps</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token comment">// 递归调用 dps 函数，传入右子节点和 k</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">dps</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token comment">// 调用深度优先搜索函数，传入根节点和 k</span>
    <span class="token keyword">return</span> res <span class="token comment">// 返回结果 res</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,10),H={id:"_199-二叉树的右视图",tabindex:"-1"},Q=n("a",{class:"header-anchor",href:"#_199-二叉树的右视图","aria-hidden":"true"},"#",-1),W={href:"https://leetcode.cn/problems/binary-tree-right-side-view/",target:"_blank",rel:"noopener noreferrer"},X=t(`<p><strong>中等</strong></p><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/14/tree.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span> <span class="token parameter">root</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">rightSideView</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">// 如果根节点为空，返回一个空数组</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>  <span class="token comment">// 定义结果数组 res 和辅助队列 queue，初始将根节点放入队列中</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 循环直到队列为空</span>
    <span class="token keyword">const</span> length <span class="token operator">=</span> queue<span class="token punctuation">.</span>length  <span class="token comment">// 获取当前队列的长度</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 遍历当前层的节点</span>
      <span class="token keyword">let</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 取出队首节点</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">===</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 如果当前节点是当前层的最后一个节点</span>
        res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>  <span class="token comment">// 将当前节点的值存入结果数组 res 中</span>
      <span class="token punctuation">}</span>
      node<span class="token punctuation">.</span>left <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>  <span class="token comment">// 如果当前节点有左子节点，则将左子节点加入队列中</span>
      node<span class="token punctuation">.</span>right <span class="token operator">&amp;&amp;</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>  <span class="token comment">// 如果当前节点有右子节点，则将右子节点加入队列中</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res  <span class="token comment">// 返回存储了右视图节点值的结果数组 res</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,6),Z={id:"_114-二叉树展开为链表",tabindex:"-1"},$=n("a",{class:"header-anchor",href:"#_114-二叉树展开为链表","aria-hidden":"true"},"#",-1),nn={href:"https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/",target:"_blank",rel:"noopener noreferrer"},sn=n("p",null,[n("strong",null,"中等")],-1),an=n("p",null,[s("给你二叉树的根结点 "),n("code",null,"root"),s(" ，请你将它展开为一个单链表：")],-1),en=n("li",null,[s("展开后的单链表应该同样使用 "),n("code",null,"TreeNode"),s(" ，其中 "),n("code",null,"right"),s(" 子指针指向链表中下一个结点，而左子指针始终为 "),n("code",null,"null"),s(" 。")],-1),tn={href:"https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin",target:"_blank",rel:"noopener noreferrer"},pn=n("strong",null,"先序遍历",-1),on=t(`<p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = []
输出：[]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,5),ln={href:"https://labuladong.online/algo/slug.html?slug=flatten-binary-tree-to-linked-list",target:"_blank",rel:"noopener noreferrer"},cn=n("strong",null,"参考",-1),rn=t(`<p><strong>给 <code>flatten</code> 函数输入一个节点 <code>root</code>，那么以 <code>root</code> 为根的二叉树就会被拉平为一条链表</strong>。</p><p>如何利用这个定义来完成算法？你想想怎么把以 <code>root</code> 为根的二叉树拉平为一条链表？</p><p>很简单，以下流程：</p><p>1、将 <code>root</code> 的左子树和右子树拉平。</p><p>2、将 <code>root</code> 的右子树接到左子树下方，然后将整个左子树作为右子树。</p><p><img src="https://labuladong.github.io/pictures/二叉树系列/2.jpeg" alt="img"></p><p>至于如何把 <code>root</code> 的左右子树拉平，不用你操心，<code>flatten</code> 函数的定义就是这样，交给他做就行了。</p><p>把上面的逻辑翻译成代码，即可解决本题。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">flatten</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// base case</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token comment">// 先递归拉平左右子树</span>
    <span class="token function">flatten</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">flatten</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/****后序遍历位置****/</span>
    <span class="token comment">// 1、左右子树已经被拉平成一条链表</span>
    <span class="token keyword">var</span> left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token keyword">var</span> right <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>

    <span class="token comment">// 2、将左子树作为右子树</span>
    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    root<span class="token punctuation">.</span>right <span class="token operator">=</span> left<span class="token punctuation">;</span>

    <span class="token comment">// 3、将原先的右子树接到当前右子树的末端</span>
    <span class="token keyword">var</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    p<span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,9),un={id:"_105-从前序与中序遍历序列构造二叉树",tabindex:"-1"},dn=n("a",{class:"header-anchor",href:"#_105-从前序与中序遍历序列构造二叉树","aria-hidden":"true"},"#",-1),kn={href:"https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",target:"_blank",rel:"noopener noreferrer"},vn=t(`<p><strong>中等</strong></p><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2:</strong></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入: preorder = [-1], inorder = [-1]
输出: [-1]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,7),mn={href:"https://labuladong.online/algo/slug.html?slug=construct-binary-tree-from-preorder-and-inorder-traversal",target:"_blank",rel:"noopener noreferrer"},bn=t(`<p><strong>构造二叉树，第一件事一定是找根节点，然后想办法构造左右子树</strong>。</p><p>二叉树的前序和中序遍历结果的特点如下：</p><p><img src="https://labuladong.github.io/pictures/二叉树系列2/1.jpeg" alt="img"></p><p>前序遍历结果第一个就是根节点的值，然后再根据中序遍历结果确定左右子树的节点。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token doc-comment comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) <span class="token punctuation">{</span>
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * <span class="token punctuation">}</span>
 */</span>
<span class="token doc-comment comment">/**
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span> <span class="token parameter">preorder</span>
 * <span class="token keyword">@param</span> <span class="token class-name"><span class="token punctuation">{</span>number<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">}</span></span> <span class="token parameter">inorder</span>
 * <span class="token keyword">@return</span> <span class="token class-name"><span class="token punctuation">{</span>TreeNode<span class="token punctuation">}</span></span>
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">buildTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">preorder<span class="token punctuation">,</span> inorder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 如果前序遍历数组为空，则返回空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>preorder<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span>
    
    <span class="token comment">// 从前序遍历数组中获取根节点的值</span>
    <span class="token keyword">const</span> rootVal <span class="token operator">=</span> preorder<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token comment">// 在中序遍历数组中查找根节点值的索引</span>
    <span class="token keyword">const</span> rootIndex <span class="token operator">=</span> inorder<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span>
    
    <span class="token comment">// 创建一个根节点，值为根节点的值</span>
    <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>rootVal<span class="token punctuation">)</span>
    
    <span class="token comment">// 递归构建左子树，使用前序遍历和中序遍历数组的左部分</span>
    root<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> rootIndex<span class="token punctuation">)</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> rootIndex<span class="token punctuation">)</span><span class="token punctuation">)</span>
    
    <span class="token comment">// 递归构建右子树，使用前序遍历和中序遍历数组的右部分</span>
    root<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">buildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>rootIndex<span class="token punctuation">)</span><span class="token punctuation">,</span> inorder<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>rootIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    
    <span class="token comment">// 返回二叉树的根节点</span>
    <span class="token keyword">return</span> root
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),gn={id:"_437-路径总和-iii",tabindex:"-1"},hn=n("a",{class:"header-anchor",href:"#_437-路径总和-iii","aria-hidden":"true"},"#",-1),fn={href:"https://leetcode.cn/problems/path-sum-iii/",target:"_blank",rel:"noopener noreferrer"},yn={href:"https://leetcode.cn/problems/path-sum-iii/description/?envType=study-plan-v2&envId=top-100-liked#",target:"_blank",rel:"noopener noreferrer"},_n=t(`<p>中等</p><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p><p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解题思路 <ol><li><p><strong>递归遍历</strong>：从树的根节点开始，递归地遍历每个节点。</p></li><li><p><strong>路径总和计算</strong>：对于每个节点，以该节点为起点，向下遍历所有可能的路径，计算路径和是否等于给定的目标值。</p></li><li><p><strong>辅助函数</strong>：可以编写一个辅助函数，用于计算以当前节点为起点的路径总和个数。在该函数中，可以使用递归来遍历以当前节点为根的子树，并不断累加路径和。</p></li><li><p><strong>前缀和</strong>：在遍历过程中，可以使用一个哈希表来记录从根节点到当前节点的路径和，以及每个路径和出现的次数。</p></li><li><p><strong>路径和判断</strong>：在更新路径和的同时，查看在哈希表中是否存在之前路径和加上或减去目标值的结果，若存在则说明存在符合条件的路径。</p></li><li><p><strong>统计路径总数</strong>：最终统计符合条件的路径总数，并返回结果。</p></li></ol></li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">pathSum</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> sum</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 使用哈希表来记录路径和及其出现次数</span>
    <span class="token keyword">const</span> prefixSumCount <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// 定义递归函数，计算符合条件的路径总数</span>
    <span class="token keyword">const</span> <span class="token function-variable function">dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> currSum</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

        <span class="token comment">// 更新当前路径和</span>
        currSum <span class="token operator">+=</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
        
        <span class="token comment">// 更新符合条件的路径总数</span>
        count <span class="token operator">+=</span> prefixSumCount<span class="token punctuation">[</span>currSum <span class="token operator">-</span> sum<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 更新当前路径和在哈希表中的出现次数</span>
        prefixSumCount<span class="token punctuation">[</span>currSum<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>prefixSumCount<span class="token punctuation">[</span>currSum<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

        <span class="token comment">// 递归遍历左子树</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> currSum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 递归遍历右子树</span>
        <span class="token function">dfs</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> currSum<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 回溯，将当前路径和在哈希表中的出现次数减一</span>
        prefixSumCount<span class="token punctuation">[</span>currSum<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// 调用递归函数开始计算路径总数</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 返回符合条件的路径总数</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8),wn={id:"_236-二叉树的最近公共祖先",tabindex:"-1"},xn=n("a",{class:"header-anchor",href:"#_236-二叉树的最近公共祖先","aria-hidden":"true"},"#",-1),jn={href:"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/",target:"_blank",rel:"noopener noreferrer"},Tn=n("p",null,[n("strong",null,"中等")],-1),Nn=n("p",null,"给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。",-1),Sn={href:"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin",target:"_blank",rel:"noopener noreferrer"},qn=n("strong",null,"一个节点也可以是它自己的祖先",-1),Dn=t(`<p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>解题思路</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>
<span class="token comment">// 寻找最近公共祖先的函数</span>
<span class="token keyword">var</span> <span class="token function-variable function">lowestCommonAncestor</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 边界条件：如果当前节点为 null 或者等于 p 或 q，则直接返回当前节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> root <span class="token operator">===</span> p <span class="token operator">||</span> root <span class="token operator">===</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 递归查找左子树和右子树</span>
    <span class="token keyword">var</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 根据左右子树的情况判断最近公共祖先</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> right <span class="token comment">// p 和 q 同在右子树，最近公共祖先为 right</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left  <span class="token comment">// p 和 q 同在左子树，最近公共祖先为 left</span>
    <span class="token keyword">return</span> root  <span class="token comment">// p 和 q 分别位于当前节点的左右子树，当前节点即为最近公共祖先</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,5),En={id:"_124-二叉树中的最大路径和",tabindex:"-1"},In=n("a",{class:"header-anchor",href:"#_124-二叉树中的最大路径和","aria-hidden":"true"},"#",-1),Bn={href:"https://leetcode.cn/problems/binary-tree-maximum-path-sum/",target:"_blank",rel:"noopener noreferrer"},Cn={href:"https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?envType=study-plan-v2&envId=top-100-liked#",target:"_blank",rel:"noopener noreferrer"},An=t(`<p><strong>困难</strong></p><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img"></p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>
<span class="token keyword">var</span> <span class="token function-variable function">maxPathSum</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 定义函数 maxPathSum，接受根节点作为参数</span>
    <span class="token keyword">let</span> maxNum <span class="token operator">=</span> Number<span class="token punctuation">.</span><span class="token constant">MIN_SAFE_INTEGER</span><span class="token punctuation">;</span> <span class="token comment">// 初始化最大路径和为 JavaScript 中表示的最小安全整数</span>
    <span class="token keyword">const</span> <span class="token function-variable function">dfs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 定义深度优先搜索函数 dfs，接受一个节点作为参数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 如果节点为空，返回0</span>
        <span class="token keyword">const</span> left <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归计算左子树的最大路径和</span>
        <span class="token keyword">const</span> right <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归计算右子树的最大路径和</span>
        <span class="token keyword">const</span> interNum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>right <span class="token operator">+</span> left <span class="token operator">+</span> root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算经过当前节点的路径和</span>
        maxNum <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxNum<span class="token punctuation">,</span> interNum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新最大路径和</span>
        <span class="token keyword">const</span> outNumer <span class="token operator">=</span> root<span class="token punctuation">.</span>val <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算以当前节点为根节点向上延伸的路径和</span>
        <span class="token keyword">return</span> outNumer <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> outNumer<span class="token punctuation">;</span> <span class="token comment">// 返回向上延伸的路径和，确保不为负数</span>
    <span class="token punctuation">}</span>
    <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 dfs 函数开始遍历二叉树</span>
    <span class="token keyword">return</span> maxNum<span class="token punctuation">;</span> <span class="token comment">// 返回整棵二叉树中的最大路径和</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,11);function Vn(Mn,On){const a=o("ExternalLinkIcon");return l(),c("div",null,[r,n("h3",u,[d,s(),n("a",k,[s("94. 二叉树的中序遍历"),e(a)])]),n("p",null,[n("a",v,[s("思路"),e(a)])]),m,n("h3",b,[g,s(),n("a",h,[s("104. 二叉树的最大深度"),e(a)])]),f,n("h3",y,[_,s(),n("a",w,[s("226. 翻转二叉树"),e(a)])]),x,n("h3",j,[T,s(),n("a",N,[s("101. 对称二叉树"),e(a)])]),S,n("h3",q,[D,s(),n("a",E,[s("543. 二叉树的直径"),e(a)])]),I,n("h3",B,[C,s(),n("a",A,[s("102. 二叉树的层序遍历"),e(a)])]),V,n("h3",M,[O,s(),n("a",F,[s("108. 将有序数组转换为二叉搜索树"),e(a)])]),P,n("h3",J,[L,s(),n("a",G,[s("98. 验证二叉搜索树"),e(a)])]),K,n("h3",R,[U,s(),n("a",Y,[s("230. 二叉搜索树中第K小的元素"),e(a)])]),z,n("h3",H,[Q,s(),n("a",W,[s("199. 二叉树的右视图"),e(a)])]),X,n("h3",Z,[$,s(),n("a",nn,[s("114. 二叉树展开为链表"),e(a)])]),sn,an,n("ul",null,[en,n("li",null,[s("展开后的单链表应该与二叉树 "),n("a",tn,[pn,e(a)]),s(" 顺序相同。")])]),on,n("ul",null,[n("li",null,[s("解题思路 "),n("a",ln,[cn,e(a)])])]),rn,n("h3",un,[dn,s(),n("a",kn,[s("105. 从前序与中序遍历序列构造二叉树"),e(a)])]),vn,n("ul",null,[n("li",null,[s("解题思路 "),n("a",mn,[s("参考"),e(a)])])]),bn,n("h3",gn,[hn,s(),n("a",fn,[s("437. 路径总和 III"),e(a)])]),n("p",null,[n("a",yn,[s("思路"),e(a)])]),_n,n("h3",wn,[xn,s(),n("a",jn,[s("236. 二叉树的最近公共祖先"),e(a)])]),Tn,Nn,n("p",null,[n("a",Sn,[s("百度百科"),e(a)]),s("中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（"),qn,s("）。”")]),Dn,n("h3",En,[In,s(),n("a",Bn,[s("124. 二叉树中的最大路径和"),e(a)])]),n("p",null,[n("a",Cn,[s("思路"),e(a)])]),An])}const Pn=p(i,[["render",Vn],["__file","binary-tree.html.vue"]]);export{Pn as default};
